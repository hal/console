{"mappings":"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","sources":["<anon>","node_modules/keycloak-js/lib/keycloak.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire25b9\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"02lid\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $0070b44f7a8953d5$export$2e2bcd8739ae039; });\n// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */ /*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const $0070b44f7a8953d5$var$CONTENT_TYPE_JSON = 'application/json';\nclass $0070b44f7a8953d5$export$2e2bcd8739ae039 {\n    /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */ #refreshQueue = [];\n    /** @type {KeycloakAdapter} */ #adapter;\n    /** @type {boolean} */ #useNonce = true;\n    /** @type {CallbackStorage} */ #callbackStorage;\n    #logInfo = this.#createLogger(console.info);\n    #logWarn = this.#createLogger(console.warn);\n    /** @type {LoginIframe} */ #loginIframe = {\n        enable: true,\n        callbackList: [],\n        interval: 5\n    };\n    /** @type {KeycloakConfig} config */ #config;\n    didInitialize = false;\n    authenticated = false;\n    loginRequired = false;\n    /** @type {KeycloakResponseMode} */ responseMode = 'fragment';\n    /** @type {KeycloakResponseType} */ responseType = 'code';\n    /** @type {KeycloakFlow} */ flow = 'standard';\n    /** @type {number?} */ timeSkew = null;\n    /** @type {string=} */ redirectUri;\n    /** @type {string=} */ silentCheckSsoRedirectUri;\n    /** @type {boolean} */ silentCheckSsoFallback = true;\n    /** @type {KeycloakPkceMethod} */ pkceMethod = 'S256';\n    enableLogging = false;\n    /** @type {'GET' | 'POST'} */ logoutMethod = 'GET';\n    /** @type {string=} */ scope;\n    messageReceiveTimeout = 10000;\n    /** @type {string=} */ idToken;\n    /** @type {KeycloakTokenParsed=} */ idTokenParsed;\n    /** @type {string=} */ token;\n    /** @type {KeycloakTokenParsed=} */ tokenParsed;\n    /** @type {string=} */ refreshToken;\n    /** @type {KeycloakTokenParsed=} */ refreshTokenParsed;\n    /** @type {string=} */ clientId;\n    /** @type {string=} */ sessionId;\n    /** @type {string=} */ subject;\n    /** @type {string=} */ authServerUrl;\n    /** @type {string=} */ realm;\n    /** @type {KeycloakRoles=} */ realmAccess;\n    /** @type {KeycloakResourceAccess=} */ resourceAccess;\n    /** @type {KeycloakProfile=} */ profile;\n    /** @type {{}=} */ userInfo;\n    /** @type {Endpoints} */ endpoints;\n    /** @type {number=} */ tokenTimeoutHandle;\n    /** @type {() => void=} */ onAuthSuccess;\n    /** @type {(errorData?: KeycloakError) => void=} */ onAuthError;\n    /** @type {() => void=} */ onAuthRefreshSuccess;\n    /** @type {() => void=} */ onAuthRefreshError;\n    /** @type {() => void=} */ onTokenExpired;\n    /** @type {() => void=} */ onAuthLogout;\n    /** @type {(authenticated: boolean) => void=} */ onReady;\n    /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */ onActionUpdate;\n    /**\n   * @param {KeycloakConfig} config\n   */ constructor(config){\n        if (typeof config !== 'string' && !$0070b44f7a8953d5$var$isObject(config)) throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n        if ($0070b44f7a8953d5$var$isObject(config)) {\n            const requiredProperties = 'oidcProvider' in config ? [\n                'clientId'\n            ] : [\n                'url',\n                'realm',\n                'clientId'\n            ];\n            for (const property of requiredProperties){\n                if (!(property in config)) throw new Error(`The configuration object is missing the required '${property}' property.`);\n            }\n        }\n        if (!globalThis.isSecureContext) this.#logWarn(\"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\nContinuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\nFor more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\");\n        this.#config = config;\n    }\n    /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */ init = async (initOptions = {})=>{\n        if (this.didInitialize) throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n        this.didInitialize = true;\n        this.#callbackStorage = $0070b44f7a8953d5$var$createCallbackStorage();\n        const adapters = [\n            'default',\n            'cordova',\n            'cordova-native'\n        ];\n        if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) this.#adapter = this.#loadAdapter(initOptions.adapter);\n        else if (typeof initOptions.adapter === 'object') this.#adapter = initOptions.adapter;\n        else if ('Cordova' in window || 'cordova' in window) this.#adapter = this.#loadAdapter('cordova');\n        else this.#adapter = this.#loadAdapter('default');\n        if (typeof initOptions.useNonce !== 'undefined') this.#useNonce = initOptions.useNonce;\n        if (typeof initOptions.checkLoginIframe !== 'undefined') this.#loginIframe.enable = initOptions.checkLoginIframe;\n        if (initOptions.checkLoginIframeInterval) this.#loginIframe.interval = initOptions.checkLoginIframeInterval;\n        if (initOptions.onLoad === 'login-required') this.loginRequired = true;\n        if (initOptions.responseMode) {\n            if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') this.responseMode = initOptions.responseMode;\n            else throw new Error('Invalid value for responseMode');\n        }\n        if (initOptions.flow) {\n            switch(initOptions.flow){\n                case 'standard':\n                    this.responseType = 'code';\n                    break;\n                case 'implicit':\n                    this.responseType = 'id_token token';\n                    break;\n                case 'hybrid':\n                    this.responseType = 'code id_token token';\n                    break;\n                default:\n                    throw new Error('Invalid value for flow');\n            }\n            this.flow = initOptions.flow;\n        }\n        if (typeof initOptions.timeSkew === 'number') this.timeSkew = initOptions.timeSkew;\n        if (initOptions.redirectUri) this.redirectUri = initOptions.redirectUri;\n        if (initOptions.silentCheckSsoRedirectUri) this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n        if (typeof initOptions.silentCheckSsoFallback === 'boolean') this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n        if (typeof initOptions.pkceMethod !== 'undefined') {\n            if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n            this.pkceMethod = initOptions.pkceMethod;\n        }\n        if (typeof initOptions.enableLogging === 'boolean') this.enableLogging = initOptions.enableLogging;\n        if (initOptions.logoutMethod === 'POST') this.logoutMethod = 'POST';\n        if (typeof initOptions.scope === 'string') this.scope = initOptions.scope;\n        if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) this.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n        await this.#loadConfig();\n        await this.#check3pCookiesSupported();\n        await this.#processInit(initOptions);\n        this.onReady?.(this.authenticated);\n        return this.authenticated;\n    };\n    /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */ #loadAdapter(type) {\n        if (type === 'default') return this.#loadDefaultAdapter();\n        if (type === 'cordova') {\n            this.#loginIframe.enable = false;\n            return this.#loadCordovaAdapter();\n        }\n        if (type === 'cordova-native') {\n            this.#loginIframe.enable = false;\n            return this.#loadCordovaNativeAdapter();\n        }\n        throw new Error('invalid adapter type: ' + type);\n    }\n    /**\n   * @returns {KeycloakAdapter}\n   */ #loadDefaultAdapter() {\n        /** @type {KeycloakAdapter['redirectUri']}{} */ const redirectUri = (options)=>{\n            return options?.redirectUri || this.redirectUri || globalThis.location.href;\n        };\n        return {\n            login: async (options)=>{\n                window.location.assign(await this.createLoginUrl(options));\n                return await new Promise(()=>{});\n            },\n            logout: async (options)=>{\n                const logoutMethod = options?.logoutMethod ?? this.logoutMethod;\n                if (logoutMethod === 'GET') {\n                    window.location.replace(this.createLogoutUrl(options));\n                    return;\n                }\n                // Create form to send POST request.\n                const form = document.createElement('form');\n                form.setAttribute('method', 'POST');\n                form.setAttribute('action', this.createLogoutUrl(options));\n                form.style.display = 'none';\n                // Add data to form as hidden input fields.\n                const data = {\n                    id_token_hint: this.idToken,\n                    client_id: this.clientId,\n                    post_logout_redirect_uri: redirectUri(options)\n                };\n                for (const [name, value] of Object.entries(data)){\n                    const input = document.createElement('input');\n                    input.setAttribute('type', 'hidden');\n                    input.setAttribute('name', name);\n                    input.setAttribute('value', /** @type {string} */ value);\n                    form.appendChild(input);\n                }\n                // Append form to page and submit it to perform logout and redirect.\n                document.body.appendChild(form);\n                form.submit();\n            },\n            register: async (options)=>{\n                window.location.assign(await this.createRegisterUrl(options));\n                return await new Promise(()=>{});\n            },\n            accountManagement: async ()=>{\n                const accountUrl = this.createAccountUrl();\n                if (typeof accountUrl !== 'undefined') window.location.href = accountUrl;\n                else throw new Error('Not supported by the OIDC server');\n                return await new Promise(()=>{});\n            },\n            redirectUri: redirectUri\n        };\n    }\n    /**\n   * @returns {KeycloakAdapter}\n   */ #loadCordovaAdapter() {\n        /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */ const cordovaOpenWindowWrapper = (loginUrl, target, options)=>{\n            if (window.cordova && window.cordova.InAppBrowser) // Use inappbrowser for IOS and Android if available\n            return window.cordova.InAppBrowser.open(loginUrl, target, options);\n            else return window.open(loginUrl, target, options);\n        };\n        const shallowCloneCordovaOptions = (userOptions)=>{\n            if (userOptions && userOptions.cordovaOptions) return Object.keys(userOptions.cordovaOptions).reduce((options, optionName)=>{\n                options[optionName] = userOptions.cordovaOptions[optionName];\n                return options;\n            }, {});\n            else return {};\n        };\n        const formatCordovaOptions = (cordovaOptions)=>{\n            return Object.keys(cordovaOptions).reduce((options, optionName)=>{\n                options.push(optionName + '=' + cordovaOptions[optionName]);\n                return options;\n            }, []).join(',');\n        };\n        const createCordovaOptions = (userOptions)=>{\n            const cordovaOptions = shallowCloneCordovaOptions(userOptions);\n            cordovaOptions.location = 'no';\n            if (userOptions && userOptions.prompt === 'none') cordovaOptions.hidden = 'yes';\n            return formatCordovaOptions(cordovaOptions);\n        };\n        const getCordovaRedirectUri = ()=>{\n            return this.redirectUri || 'http://localhost';\n        };\n        return {\n            login: async (options)=>{\n                const cordovaOptions = createCordovaOptions(options);\n                const loginUrl = await this.createLoginUrl(options);\n                const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n                let completed = false;\n                let closed = false;\n                function closeBrowser() {\n                    closed = true;\n                    ref.close();\n                }\n                return await new Promise((resolve, reject)=>{\n                    ref.addEventListener('loadstart', async (event)=>{\n                        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                            const callback = this.#parseCallback(event.url);\n                            try {\n                                await this.#processCallback(callback);\n                                resolve();\n                            } catch (error) {\n                                reject(error);\n                            }\n                            closeBrowser();\n                            completed = true;\n                        }\n                    });\n                    ref.addEventListener('loaderror', async (event)=>{\n                        if (!completed) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                                const callback = this.#parseCallback(event.url);\n                                try {\n                                    await this.#processCallback(callback);\n                                    resolve();\n                                } catch (error) {\n                                    reject(error);\n                                }\n                                closeBrowser();\n                                completed = true;\n                            } else {\n                                reject(new Error('Unable to process login.'));\n                                closeBrowser();\n                            }\n                        }\n                    });\n                    ref.addEventListener('exit', function(event) {\n                        if (!closed) reject(new Error('User closed the login window.'));\n                    });\n                });\n            },\n            logout: async (options)=>{\n                const logoutUrl = this.createLogoutUrl(options);\n                const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n                let error = false;\n                ref.addEventListener('loadstart', (event)=>{\n                    if (event.url.indexOf(getCordovaRedirectUri()) === 0) ref.close();\n                });\n                ref.addEventListener('loaderror', (event)=>{\n                    if (event.url.indexOf(getCordovaRedirectUri()) === 0) ref.close();\n                    else {\n                        error = true;\n                        ref.close();\n                    }\n                });\n                await new Promise((resolve, reject)=>{\n                    ref.addEventListener('exit', ()=>{\n                        if (error) reject(new Error('User closed the login window.'));\n                        else {\n                            this.clearToken();\n                            resolve();\n                        }\n                    });\n                });\n            },\n            register: async (options)=>{\n                const registerUrl = await this.createRegisterUrl();\n                const cordovaOptions = createCordovaOptions(options);\n                const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n                /** @type {Promise<void>} */ const promise = new Promise((resolve, reject)=>{\n                    ref.addEventListener('loadstart', async (event)=>{\n                        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                            ref.close();\n                            const oauth = this.#parseCallback(event.url);\n                            try {\n                                await this.#processCallback(oauth);\n                                resolve();\n                            } catch (error) {\n                                reject(error);\n                            }\n                        }\n                    });\n                });\n                await promise;\n            },\n            accountManagement: async ()=>{\n                const accountUrl = this.createAccountUrl();\n                if (typeof accountUrl !== 'undefined') {\n                    const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) === 0) ref.close();\n                    });\n                } else throw new Error('Not supported by the OIDC server');\n            },\n            redirectUri: ()=>{\n                return getCordovaRedirectUri();\n            }\n        };\n    }\n    /**\n   * @returns {KeycloakAdapter}\n   */ #loadCordovaNativeAdapter() {\n        /* global universalLinks */ return {\n            login: async (options)=>{\n                const loginUrl = await this.createLoginUrl(options);\n                await new Promise((resolve, reject)=>{\n                    universalLinks.subscribe('keycloak', async (event)=>{\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        const oauth = this.#parseCallback(event.url);\n                        try {\n                            await this.#processCallback(oauth);\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        }\n                    });\n                    window.cordova.plugins.browsertab.openUrl(loginUrl);\n                });\n            },\n            logout: async (options)=>{\n                const logoutUrl = this.createLogoutUrl(options);\n                await new Promise((resolve)=>{\n                    universalLinks.subscribe('keycloak', ()=>{\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        this.clearToken();\n                        resolve();\n                    });\n                    window.cordova.plugins.browsertab.openUrl(logoutUrl);\n                });\n            },\n            register: async (options)=>{\n                const registerUrl = await this.createRegisterUrl(options);\n                await new Promise((resolve, reject)=>{\n                    universalLinks.subscribe('keycloak', async (event)=>{\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        const oauth = this.#parseCallback(event.url);\n                        try {\n                            await this.#processCallback(oauth);\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        }\n                    });\n                    window.cordova.plugins.browsertab.openUrl(registerUrl);\n                });\n            },\n            accountManagement: async ()=>{\n                const accountUrl = this.createAccountUrl();\n                if (typeof accountUrl !== 'undefined') window.cordova.plugins.browsertab.openUrl(accountUrl);\n                else throw new Error('Not supported by the OIDC server');\n            },\n            redirectUri: (options)=>{\n                if (options && options.redirectUri) return options.redirectUri;\n                else if (this.redirectUri) return this.redirectUri;\n                else return 'http://localhost';\n            }\n        };\n    }\n    /**\n   * @returns {Promise<void>}\n   */ async #loadConfig() {\n        if (typeof this.#config === 'string') {\n            const jsonConfig = await $0070b44f7a8953d5$var$fetchJsonConfig(this.#config);\n            this.authServerUrl = jsonConfig['auth-server-url'];\n            this.realm = jsonConfig.realm;\n            this.clientId = jsonConfig.resource;\n            this.#setupEndpoints();\n        } else {\n            this.clientId = this.#config.clientId;\n            if ('oidcProvider' in this.#config) await this.#loadOidcConfig(this.#config.oidcProvider);\n            else {\n                this.authServerUrl = this.#config.url;\n                this.realm = this.#config.realm;\n                this.#setupEndpoints();\n            }\n        }\n    }\n    /**\n   * @returns {void}\n   */ #setupEndpoints() {\n        this.endpoints = {\n            authorize: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/auth';\n            },\n            token: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/token';\n            },\n            logout: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/logout';\n            },\n            checkSessionIframe: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n            },\n            thirdPartyCookiesIframe: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n            },\n            register: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/registrations';\n            },\n            userinfo: ()=>{\n                return this.#getRealmUrl() + '/protocol/openid-connect/userinfo';\n            }\n        };\n    }\n    /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */ async #loadOidcConfig(oidcProvider) {\n        if (typeof oidcProvider === 'string') {\n            const url = `${$0070b44f7a8953d5$var$stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`;\n            const openIdConfig = await $0070b44f7a8953d5$var$fetchOpenIdConfig(url);\n            this.#setupOidcEndpoints(openIdConfig);\n        } else this.#setupOidcEndpoints(oidcProvider);\n    }\n    /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */ #setupOidcEndpoints(config) {\n        this.endpoints = {\n            authorize () {\n                return config.authorization_endpoint;\n            },\n            token () {\n                return config.token_endpoint;\n            },\n            logout () {\n                if (!config.end_session_endpoint) throw new Error('Not supported by the OIDC server');\n                return config.end_session_endpoint;\n            },\n            checkSessionIframe () {\n                if (!config.check_session_iframe) throw new Error('Not supported by the OIDC server');\n                return config.check_session_iframe;\n            },\n            register () {\n                throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode');\n            },\n            userinfo () {\n                if (!config.userinfo_endpoint) throw new Error('Not supported by the OIDC server');\n                return config.userinfo_endpoint;\n            }\n        };\n    }\n    /**\n   * @returns {Promise<void>}\n   */ async #check3pCookiesSupported() {\n        if (!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') return;\n        const iframe = document.createElement('iframe');\n        iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe());\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        /** @type {Promise<void>} */ const promise = new Promise((resolve)=>{\n            /**\n       * @param {MessageEvent} event\n       */ const messageCallback = (event)=>{\n                if (iframe.contentWindow !== event.source) return;\n                if (event.data !== 'supported' && event.data !== 'unsupported') return;\n                else if (event.data === 'unsupported') {\n                    this.#logWarn(\"[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\nFor more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers\");\n                    this.#loginIframe.enable = false;\n                    if (this.silentCheckSsoFallback) this.silentCheckSsoRedirectUri = undefined;\n                }\n                document.body.removeChild(iframe);\n                window.removeEventListener('message', messageCallback);\n                resolve();\n            };\n            window.addEventListener('message', messageCallback, false);\n        });\n        return await $0070b44f7a8953d5$var$applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.');\n    }\n    /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */ async #processInit(initOptions) {\n        const callback = this.#parseCallback(window.location.href);\n        if (callback?.newUrl) window.history.replaceState(window.history.state, '', callback.newUrl);\n        if (callback && callback.valid) {\n            await this.#setupCheckLoginIframe();\n            await this.#processCallback(callback);\n            return;\n        }\n        /** @param {boolean} prompt */ const doLogin = async (prompt)=>{\n            /** @type {KeycloakLoginOptions} */ const options = {};\n            if (!prompt) options.prompt = 'none';\n            if (initOptions.locale) options.locale = initOptions.locale;\n            await this.login(options);\n        };\n        const onLoad = async ()=>{\n            switch(initOptions.onLoad){\n                case 'check-sso':\n                    if (this.#loginIframe.enable) {\n                        await this.#setupCheckLoginIframe();\n                        const unchanged = await this.#checkLoginIframe();\n                        if (!unchanged) this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false);\n                    } else this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false);\n                    break;\n                case 'login-required':\n                    await doLogin(true);\n                    break;\n                default:\n                    throw new Error('Invalid value for onLoad');\n            }\n        };\n        if (initOptions.token && initOptions.refreshToken) {\n            this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n            if (this.#loginIframe.enable) {\n                await this.#setupCheckLoginIframe();\n                const unchanged = await this.#checkLoginIframe();\n                if (unchanged) {\n                    this.onAuthSuccess?.();\n                    this.#scheduleCheckIframe();\n                }\n            } else try {\n                await this.updateToken(-1);\n                this.onAuthSuccess?.();\n            } catch (error) {\n                this.onAuthError?.();\n                if (initOptions.onLoad) await onLoad();\n                else throw error;\n            }\n        } else if (initOptions.onLoad) await onLoad();\n    }\n    /**\n   * @returns {Promise<void>}\n   */ async #setupCheckLoginIframe() {\n        if (!this.#loginIframe.enable || this.#loginIframe.iframe) return;\n        const iframe = document.createElement('iframe');\n        this.#loginIframe.iframe = iframe;\n        iframe.setAttribute('src', this.endpoints.checkSessionIframe());\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-session-iframe');\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        /**\n     * @param {MessageEvent} event\n     */ const messageCallback = (event)=>{\n            if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) return;\n            if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) return;\n            if (event.data !== 'unchanged') this.clearToken();\n            const callbacks = this.#loginIframe.callbackList;\n            this.#loginIframe.callbackList = [];\n            for (const callback of callbacks.reverse())if (event.data === 'error') callback(new Error('Error while checking login iframe'));\n            else callback(null, event.data === 'unchanged');\n        };\n        window.addEventListener('message', messageCallback, false);\n        /** @type {Promise<void>} */ const promise = new Promise((resolve)=>{\n            iframe.addEventListener('load', ()=>{\n                const authUrl = this.endpoints.authorize();\n                if (authUrl.startsWith('/')) this.#loginIframe.iframeOrigin = globalThis.location.origin;\n                else this.#loginIframe.iframeOrigin = new URL(authUrl).origin;\n                resolve();\n            });\n        });\n        await promise;\n    }\n    /**\n   * @returns {Promise<boolean | undefined>}\n   */ async #checkLoginIframe() {\n        if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) return;\n        const message = `${this.clientId} ${this.sessionId ? this.sessionId : ''}`;\n        const origin = this.#loginIframe.iframeOrigin;\n        /** @type {Promise<boolean>} */ const promise = new Promise((resolve, reject)=>{\n            /** @type {(error: Error | null, value?: boolean) => void} */ const callback = (error, result)=>error ? reject(error) : resolve(/** @type {boolean} */ result);\n            this.#loginIframe.callbackList.push(callback);\n            if (this.#loginIframe.callbackList.length === 1) this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin);\n        });\n        return await promise;\n    }\n    /**\n   * @returns {Promise<void>}\n   */ async #checkSsoSilently() {\n        const iframe = document.createElement('iframe');\n        const src = await this.createLoginUrl({\n            prompt: 'none',\n            redirectUri: this.silentCheckSsoRedirectUri\n        });\n        iframe.setAttribute('src', src);\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-silent-check-sso');\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        return await new Promise((resolve, reject)=>{\n            /**\n       * @param {MessageEvent} event\n       */ const messageCallback = async (event)=>{\n                if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) return;\n                const oauth = this.#parseCallback(event.data);\n                try {\n                    await this.#processCallback(oauth);\n                    resolve();\n                } catch (error) {\n                    reject(error);\n                }\n                document.body.removeChild(iframe);\n                window.removeEventListener('message', messageCallback);\n            };\n            window.addEventListener('message', messageCallback);\n        });\n    }\n    /**\n   * @param {string} url\n   */ #parseCallback(url) {\n        const oauth = this.#parseCallbackUrl(url);\n        if (!oauth) return;\n        const oauthState = this.#callbackStorage.get(oauth.state);\n        if (oauthState) {\n            oauth.valid = true;\n            oauth.redirectUri = oauthState.redirectUri;\n            oauth.storedNonce = oauthState.nonce;\n            oauth.prompt = oauthState.prompt;\n            oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n            oauth.loginOptions = oauthState.loginOptions;\n        }\n        return oauth;\n    }\n    /**\n   * @param {string} urlString\n   */ #parseCallbackUrl(urlString) {\n        let supportedParams = [];\n        switch(this.flow){\n            case 'standard':\n                supportedParams = [\n                    'code',\n                    'state',\n                    'session_state',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n            case 'implicit':\n                supportedParams = [\n                    'access_token',\n                    'token_type',\n                    'id_token',\n                    'state',\n                    'session_state',\n                    'expires_in',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n            case 'hybrid':\n                supportedParams = [\n                    'access_token',\n                    'token_type',\n                    'id_token',\n                    'code',\n                    'state',\n                    'session_state',\n                    'expires_in',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n        }\n        supportedParams.push('error');\n        supportedParams.push('error_description');\n        supportedParams.push('error_uri');\n        const url = new URL(urlString);\n        let newUrl = '';\n        let parsed;\n        if (this.responseMode === 'query' && url.searchParams.size > 0) {\n            parsed = this.#parseCallbackParams(url.search, supportedParams);\n            url.search = parsed.paramsString;\n            newUrl = url.toString();\n        } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n            parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams);\n            url.hash = parsed.paramsString;\n            newUrl = url.toString();\n        }\n        if (parsed?.oauthParams) {\n            if (this.flow === 'standard' || this.flow === 'hybrid') {\n                if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            } else if (this.flow === 'implicit') {\n                if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            }\n        }\n    }\n    /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */ /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */ #parseCallbackParams(paramsString, supportedParams) {\n        const params = new URLSearchParams(paramsString);\n        /** @type {Record<string, string>} */ const oauthParams = {};\n        for (const [key, value] of Array.from(params.entries()))if (supportedParams.includes(key)) {\n            oauthParams[key] = value;\n            params.delete(key);\n        }\n        return {\n            paramsString: params.toString(),\n            oauthParams: oauthParams\n        };\n    }\n    async #processCallback(oauth) {\n        const { code: code, error: error, prompt: prompt } = oauth;\n        let timeLocal = new Date().getTime();\n        /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */ const authSuccess = (accessToken, refreshToken, idToken)=>{\n            timeLocal = (timeLocal + new Date().getTime()) / 2;\n            this.#setToken(accessToken, refreshToken, idToken, timeLocal);\n            if (this.#useNonce && this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce) {\n                this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n                this.clearToken();\n                throw new Error('Invalid nonce.');\n            }\n        };\n        if (oauth.kc_action_status) this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action);\n        if (error) {\n            if (prompt !== 'none') {\n                if (oauth.error_description && oauth.error_description === 'authentication_expired') await this.login(oauth.loginOptions);\n                else {\n                    const errorData = {\n                        error: error,\n                        error_description: oauth.error_description\n                    };\n                    this.onAuthError?.(errorData);\n                    throw errorData;\n                }\n            }\n            return;\n        } else if (this.flow !== 'standard' && (oauth.access_token || oauth.id_token)) {\n            authSuccess(oauth.access_token, undefined, oauth.id_token);\n            this.onAuthSuccess?.();\n        }\n        if (this.flow !== 'implicit' && code) try {\n            const response = await $0070b44f7a8953d5$var$fetchAccessToken(this.endpoints.token(), code, /** @type {string} */ this.clientId, oauth.redirectUri, oauth.pkceCodeVerifier);\n            authSuccess(response.access_token, response.refresh_token, response.id_token);\n            if (this.flow === 'standard') this.onAuthSuccess?.();\n            this.#scheduleCheckIframe();\n        } catch (error) {\n            this.onAuthError?.();\n            throw error;\n        }\n    }\n    async #scheduleCheckIframe() {\n        if (this.#loginIframe.enable && this.token) {\n            await $0070b44f7a8953d5$var$waitForTimeout(this.#loginIframe.interval * 1000);\n            const unchanged = await this.#checkLoginIframe();\n            if (unchanged) await this.#scheduleCheckIframe();\n        }\n    }\n    /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */ login = (options)=>{\n        return this.#adapter.login(options);\n    };\n    /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */ createLoginUrl = async (options)=>{\n        const state = $0070b44f7a8953d5$var$createUUID();\n        const nonce = $0070b44f7a8953d5$var$createUUID();\n        const redirectUri = this.#adapter.redirectUri(options);\n        /** @type {CallbackState} */ const callbackState = {\n            state: state,\n            nonce: nonce,\n            redirectUri: redirectUri,\n            loginOptions: options\n        };\n        if (options?.prompt) callbackState.prompt = options.prompt;\n        const url = options?.action === 'register' ? this.endpoints.register() : this.endpoints.authorize();\n        let scope = options?.scope || this.scope;\n        const scopeValues = scope ? scope.split(' ') : [];\n        // Ensure the 'openid' scope is always included.\n        if (!scopeValues.includes('openid')) scopeValues.unshift('openid');\n        scope = scopeValues.join(' ');\n        const params = new URLSearchParams([\n            [\n                'client_id',\n                /** @type {string} */ this.clientId\n            ],\n            [\n                'redirect_uri',\n                redirectUri\n            ],\n            [\n                'state',\n                state\n            ],\n            [\n                'response_mode',\n                this.responseMode\n            ],\n            [\n                'response_type',\n                this.responseType\n            ],\n            [\n                'scope',\n                scope\n            ]\n        ]);\n        if (this.#useNonce) params.append('nonce', nonce);\n        if (options?.prompt) params.append('prompt', options.prompt);\n        if (typeof options?.maxAge === 'number') params.append('max_age', options.maxAge.toString());\n        if (options?.loginHint) params.append('login_hint', options.loginHint);\n        if (options?.idpHint) params.append('kc_idp_hint', options.idpHint);\n        if (options?.action && options.action !== 'register') params.append('kc_action', options.action);\n        if (options?.locale) params.append('ui_locales', options.locale);\n        if (options?.acr) params.append('claims', $0070b44f7a8953d5$var$buildClaimsParameter(options.acr));\n        if (options?.acrValues) params.append('acr_values', options.acrValues);\n        if (this.pkceMethod) try {\n            const codeVerifier = $0070b44f7a8953d5$var$generateCodeVerifier(96);\n            const pkceChallenge = await $0070b44f7a8953d5$var$generatePkceChallenge(this.pkceMethod, codeVerifier);\n            callbackState.pkceCodeVerifier = codeVerifier;\n            params.append('code_challenge', pkceChallenge);\n            params.append('code_challenge_method', this.pkceMethod);\n        } catch (error) {\n            throw new Error('Failed to generate PKCE challenge.', {\n                cause: error\n            });\n        }\n        this.#callbackStorage.add(callbackState);\n        return `${url}?${params.toString()}`;\n    };\n    /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */ logout = (options)=>{\n        return this.#adapter.logout(options);\n    };\n    /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */ createLogoutUrl = (options)=>{\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod;\n        const url = this.endpoints.logout();\n        if (logoutMethod === 'POST') return url;\n        const params = new URLSearchParams([\n            [\n                'client_id',\n                /** @type {string} */ this.clientId\n            ],\n            [\n                'post_logout_redirect_uri',\n                this.#adapter.redirectUri(options)\n            ]\n        ]);\n        if (this.idToken) params.append('id_token_hint', this.idToken);\n        return `${url}?${params.toString()}`;\n    };\n    /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */ register = (options)=>{\n        return this.#adapter.register(options);\n    };\n    /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */ createRegisterUrl = (options)=>{\n        return this.createLoginUrl({\n            ...options,\n            action: 'register'\n        });\n    };\n    /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */ createAccountUrl = (options)=>{\n        const url = this.#getRealmUrl();\n        if (!url) throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.');\n        const params = new URLSearchParams([\n            [\n                'referrer',\n                /** @type {string} */ this.clientId\n            ],\n            [\n                'referrer_uri',\n                this.#adapter.redirectUri(options)\n            ]\n        ]);\n        return `${url}/account?${params.toString()}`;\n    };\n    /**\n   * @returns {Promise<void>}\n   */ accountManagement = ()=>{\n        return this.#adapter.accountManagement();\n    };\n    /**\n   * @param {string} role\n   * @returns {boolean}\n   */ hasRealmRole = (role)=>{\n        const access = this.realmAccess;\n        return !!access && access.roles.indexOf(role) >= 0;\n    };\n    /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */ hasResourceRole = (role, resource)=>{\n        if (!this.resourceAccess) return false;\n        const access = this.resourceAccess[resource || /** @type {string} */ this.clientId];\n        return !!access && access.roles.indexOf(role) >= 0;\n    };\n    /**\n   * @returns {Promise<KeycloakProfile>}\n   */ loadUserProfile = async ()=>{\n        const realmUrl = this.#getRealmUrl();\n        if (!realmUrl) throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.');\n        const url = `${realmUrl}/account`;\n        /** @type {KeycloakProfile} */ const profile = await $0070b44f7a8953d5$var$fetchJSON(url, {\n            headers: [\n                $0070b44f7a8953d5$var$buildAuthorizationHeader(this.token)\n            ]\n        });\n        return this.profile = profile;\n    };\n    /**\n   * @returns {Promise<{}>}\n   */ loadUserInfo = async ()=>{\n        const url = this.endpoints.userinfo();\n        /** @type {{}} */ const userInfo = await $0070b44f7a8953d5$var$fetchJSON(url, {\n            headers: [\n                $0070b44f7a8953d5$var$buildAuthorizationHeader(this.token)\n            ]\n        });\n        return this.userInfo = userInfo;\n    };\n    /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */ isTokenExpired = (minValidity)=>{\n        if (!this.tokenParsed || !this.refreshToken && this.flow !== 'implicit') throw new Error('Not authenticated');\n        if (this.timeSkew == null) {\n            this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n            return true;\n        }\n        if (typeof this.tokenParsed.exp !== 'number') return false;\n        let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew;\n        if (minValidity) {\n            if (isNaN(minValidity)) throw new Error('Invalid minValidity');\n            expiresIn -= minValidity;\n        }\n        return expiresIn < 0;\n    };\n    /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */ updateToken = async (minValidity)=>{\n        if (!this.refreshToken) throw new Error('Unable to update token, no refresh token available.');\n        minValidity = minValidity || 5;\n        if (this.#loginIframe.enable) await this.#checkLoginIframe();\n        let refreshToken = false;\n        if (minValidity === -1) {\n            refreshToken = true;\n            this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n        } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n            refreshToken = true;\n            this.#logInfo('[KEYCLOAK] Refreshing token: token expired');\n        }\n        if (!refreshToken) return false;\n        /** @type {PromiseWithResolvers<boolean>} */ const { promise: promise, resolve: resolve, reject: reject } = Promise.withResolvers();\n        this.#refreshQueue.push({\n            resolve: resolve,\n            reject: reject\n        });\n        if (this.#refreshQueue.length === 1) {\n            const url = this.endpoints.token();\n            let timeLocal = new Date().getTime();\n            try {\n                const response = await $0070b44f7a8953d5$var$fetchRefreshToken(url, this.refreshToken, /** @type {string} */ this.clientId);\n                this.#logInfo('[KEYCLOAK] Token refreshed');\n                timeLocal = (timeLocal + new Date().getTime()) / 2;\n                this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal);\n                this.onAuthRefreshSuccess?.();\n                for(let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop())p.resolve(true);\n            } catch (error) {\n                this.#logWarn('[KEYCLOAK] Failed to refresh token');\n                if (error instanceof $0070b44f7a8953d5$export$bae979e68e4dc802 && error.response.status === 400) this.clearToken();\n                this.onAuthRefreshError?.();\n                for(let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop())p.reject(error);\n            }\n        }\n        return await promise;\n    };\n    clearToken = ()=>{\n        if (this.token) {\n            this.#setToken();\n            this.onAuthLogout?.();\n            if (this.loginRequired) this.login();\n        }\n    };\n    /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */ #setToken(token, refreshToken, idToken, timeLocal) {\n        if (this.tokenTimeoutHandle) {\n            clearTimeout(this.tokenTimeoutHandle);\n            this.tokenTimeoutHandle = undefined;\n        }\n        if (refreshToken) {\n            this.refreshToken = refreshToken;\n            this.refreshTokenParsed = $0070b44f7a8953d5$var$decodeToken(refreshToken);\n        } else {\n            delete this.refreshToken;\n            delete this.refreshTokenParsed;\n        }\n        if (idToken) {\n            this.idToken = idToken;\n            this.idTokenParsed = $0070b44f7a8953d5$var$decodeToken(idToken);\n        } else {\n            delete this.idToken;\n            delete this.idTokenParsed;\n        }\n        if (token) {\n            this.token = token;\n            this.tokenParsed = $0070b44f7a8953d5$var$decodeToken(token);\n            this.sessionId = this.tokenParsed.sid;\n            this.authenticated = true;\n            this.subject = this.tokenParsed.sub;\n            this.realmAccess = this.tokenParsed.realm_access;\n            this.resourceAccess = this.tokenParsed.resource_access;\n            if (timeLocal) this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat;\n            if (this.timeSkew !== null) {\n                this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds');\n                if (this.onTokenExpired) {\n                    const expiresIn = (this.tokenParsed.exp - new Date().getTime() / 1000 + this.timeSkew) * 1000;\n                    this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n                    if (expiresIn <= 0) this.onTokenExpired();\n                    else this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn);\n                }\n            }\n        } else {\n            delete this.token;\n            delete this.tokenParsed;\n            delete this.subject;\n            delete this.realmAccess;\n            delete this.resourceAccess;\n            this.authenticated = false;\n        }\n    }\n    /**\n   * @returns {string=}\n   */ #getRealmUrl() {\n        if (typeof this.authServerUrl === 'undefined') return;\n        return `${$0070b44f7a8953d5$var$stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */ this.realm)}`;\n    }\n    /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */ #createLogger(fn) {\n        return (message)=>{\n            if (this.enableLogging) fn.call(console, message);\n        };\n    }\n}\n/**\n * @returns {string}\n */ function $0070b44f7a8953d5$var$createUUID() {\n    if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') throw new Error('Web Crypto API is not available.');\n    return crypto.randomUUID();\n}\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */ function $0070b44f7a8953d5$var$buildClaimsParameter(requestedAcr) {\n    return JSON.stringify({\n        id_token: {\n            acr: requestedAcr\n        }\n    });\n}\n/**\n * @param {number} len\n * @returns {string}\n */ function $0070b44f7a8953d5$var$generateCodeVerifier(len) {\n    return $0070b44f7a8953d5$var$generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n}\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */ async function $0070b44f7a8953d5$var$generatePkceChallenge(pkceMethod, codeVerifier) {\n    if (pkceMethod !== 'S256') throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n    // hash codeVerifier, then encode as url-safe base64 without padding\n    const hashBytes = new Uint8Array(await $0070b44f7a8953d5$var$sha256Digest(codeVerifier));\n    const encodedHash = $0070b44f7a8953d5$var$bytesToBase64(hashBytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    return encodedHash;\n}\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */ function $0070b44f7a8953d5$var$generateRandomString(len, alphabet) {\n    const randomData = $0070b44f7a8953d5$var$generateRandomData(len);\n    const chars = new Array(len);\n    for(let i = 0; i < len; i++)chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n    return String.fromCharCode.apply(null, chars);\n}\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */ function $0070b44f7a8953d5$var$generateRandomData(len) {\n    if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') throw new Error('Web Crypto API is not available.');\n    return crypto.getRandomValues(new Uint8Array(len));\n}\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */ function $0070b44f7a8953d5$var$applyTimeoutToPromise(promise, timeout, errorMessage) {\n    /** @type {number} */ let timeoutHandle;\n    const timeoutPromise = new Promise(function(resolve, reject) {\n        timeoutHandle = window.setTimeout(function() {\n            reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'));\n        }, timeout);\n    });\n    return Promise.race([\n        promise,\n        timeoutPromise\n    ]).finally(function() {\n        clearTimeout(timeoutHandle);\n    });\n}\n/**\n * @returns {CallbackStorage}\n */ function $0070b44f7a8953d5$var$createCallbackStorage() {\n    try {\n        return new $0070b44f7a8953d5$var$LocalStorage();\n    } catch (err) {\n        return new $0070b44f7a8953d5$var$CookieStorage();\n    }\n}\nconst $0070b44f7a8953d5$var$STORAGE_KEY_PREFIX = 'kc-callback-';\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */ /**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */ /**\n * @implements {CallbackStorage}\n */ class $0070b44f7a8953d5$var$LocalStorage {\n    constructor(){\n        globalThis.localStorage.setItem('kc-test', 'test');\n        globalThis.localStorage.removeItem('kc-test');\n    }\n    /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */ get(state) {\n        if (!state) return null;\n        this.#clearInvalidValues();\n        const key = $0070b44f7a8953d5$var$STORAGE_KEY_PREFIX + state;\n        const value = globalThis.localStorage.getItem(key);\n        if (value) {\n            globalThis.localStorage.removeItem(key);\n            return JSON.parse(value);\n        }\n        return null;\n    }\n    /**\n   * @param {CallbackState} state\n   */ add(state) {\n        this.#clearInvalidValues();\n        const key = $0070b44f7a8953d5$var$STORAGE_KEY_PREFIX + state.state;\n        const value = JSON.stringify({\n            ...state,\n            // Set the expiry time to 1 hour from now.\n            expires: Date.now() + 3600000\n        });\n        try {\n            globalThis.localStorage.setItem(key, value);\n        } catch (error) {\n            // If the storage is full, clear all known values and try again.\n            this.#clearAllValues();\n            globalThis.localStorage.setItem(key, value);\n        }\n    }\n    /**\n   * Clears all values from local storage that are no longer valid.\n   */ #clearInvalidValues() {\n        const currentTime = Date.now();\n        for (const [key, value] of this.#getStoredEntries()){\n            // Attempt to parse the expiry time from the value.\n            const expiry = this.#parseExpiry(value);\n            // Discard the value if it is malformed or expired.\n            if (expiry === null || expiry < currentTime) globalThis.localStorage.removeItem(key);\n        }\n    }\n    /**\n   * Clears all known values from local storage.\n   */ #clearAllValues() {\n        for (const [key] of this.#getStoredEntries())globalThis.localStorage.removeItem(key);\n    }\n    /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */ #getStoredEntries() {\n        return Object.entries(globalThis.localStorage).filter(([key])=>key.startsWith($0070b44f7a8953d5$var$STORAGE_KEY_PREFIX));\n    }\n    /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */ #parseExpiry(value) {\n        let parsedValue;\n        // Attempt to parse the value as JSON.\n        try {\n            parsedValue = JSON.parse(value);\n        } catch (error) {\n            return null;\n        }\n        // Attempt to extract the 'expires' property.\n        if ($0070b44f7a8953d5$var$isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') return parsedValue.expires;\n        return null;\n    }\n}\n/**\n * @implements {CallbackStorage}\n */ class $0070b44f7a8953d5$var$CookieStorage {\n    /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */ get(state) {\n        if (!state) return null;\n        const value = this.#getCookie($0070b44f7a8953d5$var$STORAGE_KEY_PREFIX + state);\n        this.#setCookie($0070b44f7a8953d5$var$STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100));\n        if (value) return JSON.parse(value);\n        return null;\n    }\n    /**\n   * @param {CallbackState} state\n   */ add(state) {\n        this.#setCookie($0070b44f7a8953d5$var$STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60));\n    }\n    /**\n   * @param {string} key\n   * @returns\n   */ #getCookie(key) {\n        const name = key + '=';\n        const ca = document.cookie.split(';');\n        for(let i = 0; i < ca.length; i++){\n            let c = ca[i];\n            while(c.charAt(0) === ' ')c = c.substring(1);\n            if (c.indexOf(name) === 0) return c.substring(name.length, c.length);\n        }\n        return '';\n    }\n    /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */ #setCookie(key, value, expirationDate) {\n        const cookie = key + '=' + value + '; ' + 'expires=' + expirationDate.toUTCString() + '; ';\n        document.cookie = cookie;\n    }\n    /**\n   * @param {number} minutes\n   * @returns {Date}\n   */ #cookieExpiration(minutes) {\n        const exp = new Date();\n        exp.setTime(exp.getTime() + minutes * 60000);\n        return exp;\n    }\n}\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */ function $0070b44f7a8953d5$var$bytesToBase64(bytes) {\n    const binString = String.fromCodePoint(...bytes);\n    return btoa(binString);\n}\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */ async function $0070b44f7a8953d5$var$sha256Digest(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') throw new Error('Web Crypto API is not available.');\n    return await crypto.subtle.digest('SHA-256', data);\n}\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */ function $0070b44f7a8953d5$var$decodeToken(token) {\n    const [, payload] = token.split('.');\n    if (typeof payload !== 'string') throw new Error('Unable to decode token, payload not found.');\n    let decoded;\n    try {\n        decoded = $0070b44f7a8953d5$var$base64UrlDecode(payload);\n    } catch (error) {\n        throw new Error('Unable to decode token, payload is not a valid Base64URL value.', {\n            cause: error\n        });\n    }\n    try {\n        return JSON.parse(decoded);\n    } catch (error) {\n        throw new Error('Unable to decode token, payload is not a valid JSON value.', {\n            cause: error\n        });\n    }\n}\n/**\n * @param {string} input\n */ function $0070b44f7a8953d5$var$base64UrlDecode(input) {\n    let output = input.replaceAll('-', '+').replaceAll('_', '/');\n    switch(output.length % 4){\n        case 0:\n            break;\n        case 2:\n            output += '==';\n            break;\n        case 3:\n            output += '=';\n            break;\n        default:\n            throw new Error('Input is not of the correct length.');\n    }\n    try {\n        return $0070b44f7a8953d5$var$b64DecodeUnicode(output);\n    } catch (error) {\n        return atob(output);\n    }\n}\n/**\n * @param {string} input\n */ function $0070b44f7a8953d5$var$b64DecodeUnicode(input) {\n    return decodeURIComponent(atob(input).replace(/(.)/g, (m, p)=>{\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) code = '0' + code;\n        return '%' + code;\n    }));\n}\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */ function $0070b44f7a8953d5$var$isObject(input) {\n    return typeof input === 'object' && input !== null;\n}\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */ /**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */ async function $0070b44f7a8953d5$var$fetchJsonConfig(url) {\n    return await $0070b44f7a8953d5$var$fetchJSON(url);\n}\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */ async function $0070b44f7a8953d5$var$fetchOpenIdConfig(url) {\n    return await $0070b44f7a8953d5$var$fetchJSON(url);\n}\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */ /**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */ async function $0070b44f7a8953d5$var$fetchAccessToken(url, code, clientId, redirectUri, pkceCodeVerifier) {\n    const body = new URLSearchParams([\n        [\n            'code',\n            code\n        ],\n        [\n            'grant_type',\n            'authorization_code'\n        ],\n        [\n            'client_id',\n            clientId\n        ],\n        [\n            'redirect_uri',\n            redirectUri\n        ]\n    ]);\n    if (pkceCodeVerifier) body.append('code_verifier', pkceCodeVerifier);\n    return await $0070b44f7a8953d5$var$fetchJSON(url, {\n        method: 'POST',\n        credentials: 'include',\n        body: body\n    });\n}\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */ async function $0070b44f7a8953d5$var$fetchRefreshToken(url, refreshToken, clientId) {\n    const body = new URLSearchParams([\n        [\n            'grant_type',\n            'refresh_token'\n        ],\n        [\n            'refresh_token',\n            refreshToken\n        ],\n        [\n            'client_id',\n            clientId\n        ]\n    ]);\n    return await $0070b44f7a8953d5$var$fetchJSON(url, {\n        method: 'POST',\n        credentials: 'include',\n        body: body\n    });\n}\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */ async function $0070b44f7a8953d5$var$fetchJSON(url, init = {}) {\n    const headers = new Headers(init.headers);\n    headers.set('Accept', $0070b44f7a8953d5$var$CONTENT_TYPE_JSON);\n    const response = await $0070b44f7a8953d5$var$fetchWithErrorHandling(url, {\n        ...init,\n        headers: headers\n    });\n    return await response.json();\n}\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */ async function $0070b44f7a8953d5$var$fetchWithErrorHandling(url, init) {\n    const response = await fetch(url, init);\n    if (!response.ok) throw new $0070b44f7a8953d5$export$bae979e68e4dc802('Server responded with an invalid status.', {\n        response: response\n    });\n    return response;\n}\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */ function $0070b44f7a8953d5$var$buildAuthorizationHeader(token) {\n    if (!token) throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.');\n    return [\n        'Authorization',\n        `bearer ${token}`\n    ];\n}\n/**\n * @param {string} url\n * @returns {string}\n */ function $0070b44f7a8953d5$var$stripTrailingSlash(url) {\n    return url.endsWith('/') ? url.slice(0, -1) : url;\n}\nclass $0070b44f7a8953d5$export$bae979e68e4dc802 extends Error {\n    /** @type {Response} */ response;\n    /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */ constructor(message, options){\n        super(message, options);\n        this.response = options.response;\n    }\n}\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */ const $0070b44f7a8953d5$var$waitForTimeout = (delay)=>new Promise((resolve)=>setTimeout(resolve, delay));\n\n});\n\n\n//# sourceMappingURL=keycloak.1ffe3714.js.map\n","// @ts-check\n/**\n * @import {Acr, KeycloakAccountOptions, KeycloakAdapter, KeycloakConfig, KeycloakError, KeycloakFlow, KeycloakInitOptions, KeycloakLoginOptions, KeycloakLogoutOptions, KeycloakPkceMethod, KeycloakProfile, KeycloakRegisterOptions, KeycloakResourceAccess, KeycloakResponseMode, KeycloakResponseType, KeycloakRoles, KeycloakTokenParsed, OpenIdProviderMetadata} from \"./keycloak.ts\"\n */\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst CONTENT_TYPE_JSON = 'application/json'\n\n/**\n * @typedef {Object} Endpoints\n * @property {() => string} authorize\n * @property {() => string} token\n * @property {() => string} logout\n * @property {() => string} checkSessionIframe\n * @property {() => string=} thirdPartyCookiesIframe\n * @property {() => string} register\n * @property {() => string} userinfo\n */\n\n/**\n * @typedef {Object} LoginIframe\n * @property {boolean} enable\n * @property {((error: Error | null, value?: boolean) => void)[]} callbackList\n * @property {number} interval\n * @property {HTMLIFrameElement=} iframe\n * @property {string=} iframeOrigin\n */\n\nexport default class Keycloak {\n  /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */\n  #refreshQueue = []\n  /** @type {KeycloakAdapter} */\n  #adapter\n  /** @type {boolean} */\n  #useNonce = true\n  /** @type {CallbackStorage} */\n  #callbackStorage\n  #logInfo = this.#createLogger(console.info)\n  #logWarn = this.#createLogger(console.warn)\n  /** @type {LoginIframe} */\n  #loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  }\n\n  /** @type {KeycloakConfig} config */\n  #config\n  didInitialize = false\n  authenticated = false\n  loginRequired = false\n  /** @type {KeycloakResponseMode} */\n  responseMode = 'fragment'\n  /** @type {KeycloakResponseType} */\n  responseType = 'code'\n  /** @type {KeycloakFlow} */\n  flow = 'standard'\n  /** @type {number?} */\n  timeSkew = null\n  /** @type {string=} */\n  redirectUri\n  /** @type {string=} */\n  silentCheckSsoRedirectUri\n  /** @type {boolean} */\n  silentCheckSsoFallback = true\n  /** @type {KeycloakPkceMethod} */\n  pkceMethod = 'S256'\n  enableLogging = false\n  /** @type {'GET' | 'POST'} */\n  logoutMethod = 'GET'\n  /** @type {string=} */\n  scope\n  messageReceiveTimeout = 10000\n  /** @type {string=} */\n  idToken\n  /** @type {KeycloakTokenParsed=} */\n  idTokenParsed\n  /** @type {string=} */\n  token\n  /** @type {KeycloakTokenParsed=} */\n  tokenParsed\n  /** @type {string=} */\n  refreshToken\n  /** @type {KeycloakTokenParsed=} */\n  refreshTokenParsed\n  /** @type {string=} */\n  clientId\n  /** @type {string=} */\n  sessionId\n  /** @type {string=} */\n  subject\n  /** @type {string=} */\n  authServerUrl\n  /** @type {string=} */\n  realm\n  /** @type {KeycloakRoles=} */\n  realmAccess\n  /** @type {KeycloakResourceAccess=} */\n  resourceAccess\n  /** @type {KeycloakProfile=} */\n  profile\n  /** @type {{}=} */\n  userInfo\n  /** @type {Endpoints} */\n  endpoints\n  /** @type {number=} */\n  tokenTimeoutHandle\n  /** @type {() => void=} */\n  onAuthSuccess\n  /** @type {(errorData?: KeycloakError) => void=} */\n  onAuthError\n  /** @type {() => void=} */\n  onAuthRefreshSuccess\n  /** @type {() => void=} */\n  onAuthRefreshError\n  /** @type {() => void=} */\n  onTokenExpired\n  /** @type {() => void=} */\n  onAuthLogout\n  /** @type {(authenticated: boolean) => void=} */\n  onReady\n  /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */\n  onActionUpdate\n\n  /**\n   * @param {KeycloakConfig} config\n   */\n  constructor (config) {\n    if (typeof config !== 'string' && !isObject(config)) {\n      throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\")\n    }\n\n    if (isObject(config)) {\n      const requiredProperties = 'oidcProvider' in config\n        ? ['clientId']\n        : ['url', 'realm', 'clientId']\n\n      for (const property of requiredProperties) {\n        if (!(property in config)) {\n          throw new Error(`The configuration object is missing the required '${property}' property.`)\n        }\n      }\n    }\n\n    if (!globalThis.isSecureContext) {\n      this.#logWarn(\n        \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n                'Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n' +\n                'For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts'\n      )\n    }\n\n    this.#config = config\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<boolean>}\n   */\n  init = async (initOptions = {}) => {\n    if (this.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\")\n    }\n\n    this.didInitialize = true\n    this.#callbackStorage = createCallbackStorage()\n\n    const adapters = ['default', 'cordova', 'cordova-native']\n\n    if (typeof initOptions.adapter === 'string' && adapters.includes(initOptions.adapter)) {\n      this.#adapter = this.#loadAdapter(initOptions.adapter)\n    } else if (typeof initOptions.adapter === 'object') {\n      this.#adapter = initOptions.adapter\n    } else if ('Cordova' in window || 'cordova' in window) {\n      this.#adapter = this.#loadAdapter('cordova')\n    } else {\n      this.#adapter = this.#loadAdapter('default')\n    }\n\n    if (typeof initOptions.useNonce !== 'undefined') {\n      this.#useNonce = initOptions.useNonce\n    }\n\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      this.#loginIframe.enable = initOptions.checkLoginIframe\n    }\n\n    if (initOptions.checkLoginIframeInterval) {\n      this.#loginIframe.interval = initOptions.checkLoginIframeInterval\n    }\n\n    if (initOptions.onLoad === 'login-required') {\n      this.loginRequired = true\n    }\n\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        this.responseMode = initOptions.responseMode\n      } else {\n        throw new Error('Invalid value for responseMode')\n      }\n    }\n\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          this.responseType = 'code'\n          break\n        case 'implicit':\n          this.responseType = 'id_token token'\n          break\n        case 'hybrid':\n          this.responseType = 'code id_token token'\n          break\n        default:\n          throw new Error('Invalid value for flow')\n      }\n      this.flow = initOptions.flow\n    }\n\n    if (typeof initOptions.timeSkew === 'number') {\n      this.timeSkew = initOptions.timeSkew\n    }\n\n    if (initOptions.redirectUri) {\n      this.redirectUri = initOptions.redirectUri\n    }\n\n    if (initOptions.silentCheckSsoRedirectUri) {\n      this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri\n    }\n\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback\n    }\n\n    if (typeof initOptions.pkceMethod !== 'undefined') {\n      if (initOptions.pkceMethod !== 'S256' && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`)\n      }\n\n      this.pkceMethod = initOptions.pkceMethod\n    }\n\n    if (typeof initOptions.enableLogging === 'boolean') {\n      this.enableLogging = initOptions.enableLogging\n    }\n\n    if (initOptions.logoutMethod === 'POST') {\n      this.logoutMethod = 'POST'\n    }\n\n    if (typeof initOptions.scope === 'string') {\n      this.scope = initOptions.scope\n    }\n\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      this.messageReceiveTimeout = initOptions.messageReceiveTimeout\n    }\n\n    await this.#loadConfig()\n    await this.#check3pCookiesSupported()\n    await this.#processInit(initOptions)\n\n    this.onReady?.(this.authenticated)\n\n    return this.authenticated\n  }\n\n  /**\n   * @param {\"default\" | \"cordova\" | \"cordova-native\"} type\n   * @returns {KeycloakAdapter}\n   */\n  #loadAdapter (type) {\n    if (type === 'default') {\n      return this.#loadDefaultAdapter()\n    }\n\n    if (type === 'cordova') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaAdapter()\n    }\n\n    if (type === 'cordova-native') {\n      this.#loginIframe.enable = false\n      return this.#loadCordovaNativeAdapter()\n    }\n\n    throw new Error('invalid adapter type: ' + type)\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadDefaultAdapter () {\n    /** @type {KeycloakAdapter['redirectUri']}{} */\n    const redirectUri = (options) => {\n      return options?.redirectUri || this.redirectUri || globalThis.location.href\n    }\n\n    return {\n      login: async (options) => {\n        window.location.assign(await this.createLoginUrl(options))\n        return await new Promise(() => {})\n      },\n\n      logout: async (options) => {\n        const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n\n        if (logoutMethod === 'GET') {\n          window.location.replace(this.createLogoutUrl(options))\n          return\n        }\n\n        // Create form to send POST request.\n        const form = document.createElement('form')\n\n        form.setAttribute('method', 'POST')\n        form.setAttribute('action', this.createLogoutUrl(options))\n        form.style.display = 'none'\n\n        // Add data to form as hidden input fields.\n        const data = {\n          id_token_hint: this.idToken,\n          client_id: this.clientId,\n          post_logout_redirect_uri: redirectUri(options)\n        }\n\n        for (const [name, value] of Object.entries(data)) {\n          const input = document.createElement('input')\n\n          input.setAttribute('type', 'hidden')\n          input.setAttribute('name', name)\n          input.setAttribute('value', /** @type {string} */ (value))\n\n          form.appendChild(input)\n        }\n\n        // Append form to page and submit it to perform logout and redirect.\n        document.body.appendChild(form)\n        form.submit()\n      },\n\n      register: async (options) => {\n        window.location.assign(await this.createRegisterUrl(options))\n        return await new Promise(() => {})\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.location.href = accountUrl\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return await new Promise(() => {})\n      },\n\n      redirectUri\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaAdapter () {\n    /**\n     * @param {string} loginUrl\n     * @param {string} target\n     * @param {string} options\n     * @returns {WindowProxy | null}\n     */\n    const cordovaOpenWindowWrapper = (loginUrl, target, options) => {\n      if (window.cordova && window.cordova.InAppBrowser) {\n        // Use inappbrowser for IOS and Android if available\n        return window.cordova.InAppBrowser.open(loginUrl, target, options)\n      } else {\n        return window.open(loginUrl, target, options)\n      }\n    }\n\n    const shallowCloneCordovaOptions = (userOptions) => {\n      if (userOptions && userOptions.cordovaOptions) {\n        return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {\n          options[optionName] = userOptions.cordovaOptions[optionName]\n          return options\n        }, {})\n      } else {\n        return {}\n      }\n    }\n\n    const formatCordovaOptions = (cordovaOptions) => {\n      return Object.keys(cordovaOptions).reduce((options, optionName) => {\n        options.push(optionName + '=' + cordovaOptions[optionName])\n        return options\n      }, []).join(',')\n    }\n\n    const createCordovaOptions = (userOptions) => {\n      const cordovaOptions = shallowCloneCordovaOptions(userOptions)\n      cordovaOptions.location = 'no'\n      if (userOptions && userOptions.prompt === 'none') {\n        cordovaOptions.hidden = 'yes'\n      }\n      return formatCordovaOptions(cordovaOptions)\n    }\n\n    const getCordovaRedirectUri = () => {\n      return this.redirectUri || 'http://localhost'\n    }\n\n    return {\n      login: async (options) => {\n        const cordovaOptions = createCordovaOptions(options)\n        const loginUrl = await this.createLoginUrl(options)\n        const ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions)\n        let completed = false\n        let closed = false\n\n        function closeBrowser () {\n          closed = true\n          ref.close()\n        };\n\n        return await new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              const callback = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(callback)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n              closeBrowser()\n              completed = true\n            }\n          })\n\n          ref.addEventListener('loaderror', async (event) => {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n                const callback = this.#parseCallback(event.url)\n                try {\n                  await this.#processCallback(callback)\n                  resolve()\n                } catch (error) {\n                  reject(error)\n                }\n                closeBrowser()\n                completed = true\n              } else {\n                reject(new Error('Unable to process login.'))\n                closeBrowser()\n              }\n            }\n          })\n\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              reject(new Error('User closed the login window.'))\n            }\n          })\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n        const ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes')\n        let error = false\n\n        ref.addEventListener('loadstart', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          }\n        })\n\n        ref.addEventListener('loaderror', (event) => {\n          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n            ref.close()\n          } else {\n            error = true\n            ref.close()\n          }\n        })\n\n        await new Promise((resolve, reject) => {\n          ref.addEventListener('exit', () => {\n            if (error) {\n              reject(new Error('User closed the login window.'))\n            } else {\n              this.clearToken()\n              resolve()\n            }\n          })\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl()\n        const cordovaOptions = createCordovaOptions(options)\n        const ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions)\n\n        /** @type {Promise<void>} */\n        const promise = new Promise((resolve, reject) => {\n          ref.addEventListener('loadstart', async (event) => {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n              const oauth = this.#parseCallback(event.url)\n\n              try {\n                await this.#processCallback(oauth)\n                resolve()\n              } catch (error) {\n                reject(error)\n              }\n            }\n          })\n        })\n\n        await promise\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          const ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no')\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {\n              ref.close()\n            }\n          })\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: () => {\n        return getCordovaRedirectUri()\n      }\n    }\n  }\n\n  /**\n   * @returns {KeycloakAdapter}\n   */\n  #loadCordovaNativeAdapter () {\n    /* global universalLinks */\n    return {\n      login: async (options) => {\n        const loginUrl = await this.createLoginUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(loginUrl)\n        })\n      },\n\n      logout: async (options) => {\n        const logoutUrl = this.createLogoutUrl(options)\n\n        await new Promise((resolve) => {\n          universalLinks.subscribe('keycloak', () => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            this.clearToken()\n            resolve()\n          })\n\n          window.cordova.plugins.browsertab.openUrl(logoutUrl)\n        })\n      },\n\n      register: async (options) => {\n        const registerUrl = await this.createRegisterUrl(options)\n\n        await new Promise((resolve, reject) => {\n          universalLinks.subscribe('keycloak', async (event) => {\n            universalLinks.unsubscribe('keycloak')\n            window.cordova.plugins.browsertab.close()\n            const oauth = this.#parseCallback(event.url)\n            try {\n              await this.#processCallback(oauth)\n              resolve()\n            } catch (error) {\n              reject(error)\n            }\n          })\n\n          window.cordova.plugins.browsertab.openUrl(registerUrl)\n        })\n      },\n\n      accountManagement: async () => {\n        const accountUrl = this.createAccountUrl()\n        if (typeof accountUrl !== 'undefined') {\n          window.cordova.plugins.browsertab.openUrl(accountUrl)\n        } else {\n          throw new Error('Not supported by the OIDC server')\n        }\n      },\n\n      redirectUri: (options) => {\n        if (options && options.redirectUri) {\n          return options.redirectUri\n        } else if (this.redirectUri) {\n          return this.redirectUri\n        } else {\n          return 'http://localhost'\n        }\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #loadConfig () {\n    if (typeof this.#config === 'string') {\n      const jsonConfig = await fetchJsonConfig(this.#config)\n      this.authServerUrl = jsonConfig['auth-server-url']\n      this.realm = jsonConfig.realm\n      this.clientId = jsonConfig.resource\n      this.#setupEndpoints()\n    } else {\n      this.clientId = this.#config.clientId\n\n      if ('oidcProvider' in this.#config) {\n        await this.#loadOidcConfig(this.#config.oidcProvider)\n      } else {\n        this.authServerUrl = this.#config.url\n        this.realm = this.#config.realm\n        this.#setupEndpoints()\n      }\n    }\n  }\n\n  /**\n   * @returns {void}\n   */\n  #setupEndpoints () {\n    this.endpoints = {\n      authorize: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/auth'\n      },\n      token: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/token'\n      },\n      logout: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/logout'\n      },\n      checkSessionIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html'\n      },\n      thirdPartyCookiesIframe: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html'\n      },\n      register: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/registrations'\n      },\n      userinfo: () => {\n        return this.#getRealmUrl() + '/protocol/openid-connect/userinfo'\n      }\n    }\n  }\n\n  /**\n   * @param {string | OpenIdProviderMetadata} oidcProvider\n   * @returns {Promise<void>}\n   */\n  async #loadOidcConfig (oidcProvider) {\n    if (typeof oidcProvider === 'string') {\n      const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`\n      const openIdConfig = await fetchOpenIdConfig(url)\n      this.#setupOidcEndpoints(openIdConfig)\n    } else {\n      this.#setupOidcEndpoints(oidcProvider)\n    }\n  }\n\n  /**\n   * @param {OpenIdProviderMetadata} config\n   * @returns {void}\n   */\n  #setupOidcEndpoints (config) {\n    this.endpoints = {\n      authorize () {\n        return config.authorization_endpoint\n      },\n      token () {\n        return config.token_endpoint\n      },\n      logout () {\n        if (!config.end_session_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.end_session_endpoint\n      },\n      checkSessionIframe () {\n        if (!config.check_session_iframe) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.check_session_iframe\n      },\n      register () {\n        throw new Error('Redirection to \"Register user\" page not supported in standard OIDC mode')\n      },\n      userinfo () {\n        if (!config.userinfo_endpoint) {\n          throw new Error('Not supported by the OIDC server')\n        }\n        return config.userinfo_endpoint\n      }\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #check3pCookiesSupported () {\n    if ((!this.#loginIframe.enable && !this.silentCheckSsoRedirectUri) || typeof this.endpoints.thirdPartyCookiesIframe !== 'function') {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    iframe.setAttribute('src', this.endpoints.thirdPartyCookiesIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-3p-check-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = (event) => {\n        if (iframe.contentWindow !== event.source) {\n          return\n        }\n\n        if (event.data !== 'supported' && event.data !== 'unsupported') {\n          return\n        } else if (event.data === 'unsupported') {\n          this.#logWarn(\n            '[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n' +\n                        ' - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n' +\n                        ' - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n' +\n                        'For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers'\n          )\n\n          this.#loginIframe.enable = false\n          if (this.silentCheckSsoFallback) {\n            this.silentCheckSsoRedirectUri = undefined\n          }\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n        resolve()\n      }\n\n      window.addEventListener('message', messageCallback, false)\n    })\n\n    return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, 'Timeout when waiting for 3rd party check iframe message.')\n  }\n\n  /**\n   * @param {KeycloakInitOptions} initOptions\n   * @returns {Promise<void>}\n   */\n  async #processInit (initOptions) {\n    const callback = this.#parseCallback(window.location.href)\n\n    if (callback?.newUrl) {\n      window.history.replaceState(window.history.state, '', callback.newUrl)\n    }\n\n    if (callback && callback.valid) {\n      await this.#setupCheckLoginIframe()\n      await this.#processCallback(callback)\n      return\n    }\n\n    /** @param {boolean} prompt */\n    const doLogin = async (prompt) => {\n      /** @type {KeycloakLoginOptions} */\n      const options = {}\n\n      if (!prompt) {\n        options.prompt = 'none'\n      }\n\n      if (initOptions.locale) {\n        options.locale = initOptions.locale\n      }\n\n      await this.login(options)\n    }\n\n    const onLoad = async () => {\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (this.#loginIframe.enable) {\n            await this.#setupCheckLoginIframe()\n            const unchanged = await this.#checkLoginIframe()\n\n            if (!unchanged) {\n              this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n            }\n          } else {\n            this.silentCheckSsoRedirectUri ? await this.#checkSsoSilently() : await doLogin(false)\n          }\n          break\n        case 'login-required':\n          await doLogin(true)\n          break\n        default:\n          throw new Error('Invalid value for onLoad')\n      }\n    }\n\n    if (initOptions.token && initOptions.refreshToken) {\n      this.#setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken)\n\n      if (this.#loginIframe.enable) {\n        await this.#setupCheckLoginIframe()\n        const unchanged = await this.#checkLoginIframe()\n\n        if (unchanged) {\n          this.onAuthSuccess?.()\n          this.#scheduleCheckIframe()\n        }\n      } else {\n        try {\n          await this.updateToken(-1)\n          this.onAuthSuccess?.()\n        } catch (error) {\n          this.onAuthError?.()\n          if (initOptions.onLoad) {\n            await onLoad()\n          } else {\n            throw error\n          }\n        }\n      }\n    } else if (initOptions.onLoad) {\n      await onLoad()\n    }\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #setupCheckLoginIframe () {\n    if (!this.#loginIframe.enable || this.#loginIframe.iframe) {\n      return\n    }\n\n    const iframe = document.createElement('iframe')\n    this.#loginIframe.iframe = iframe\n    iframe.setAttribute('src', this.endpoints.checkSessionIframe())\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-session-iframe')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    /**\n     * @param {MessageEvent} event\n     */\n    const messageCallback = (event) => {\n      if (event.origin !== this.#loginIframe.iframeOrigin || this.#loginIframe.iframe?.contentWindow !== event.source) {\n        return\n      }\n\n      if (!(event.data === 'unchanged' || event.data === 'changed' || event.data === 'error')) {\n        return\n      }\n\n      if (event.data !== 'unchanged') {\n        this.clearToken()\n      }\n\n      const callbacks = this.#loginIframe.callbackList\n      this.#loginIframe.callbackList = []\n\n      for (const callback of callbacks.reverse()) {\n        if (event.data === 'error') {\n          callback(new Error('Error while checking login iframe'))\n        } else {\n          callback(null, event.data === 'unchanged')\n        }\n      }\n    }\n\n    window.addEventListener('message', messageCallback, false)\n\n    /** @type {Promise<void>} */\n    const promise = new Promise((resolve) => {\n      iframe.addEventListener('load', () => {\n        const authUrl = this.endpoints.authorize()\n        if (authUrl.startsWith('/')) {\n          this.#loginIframe.iframeOrigin = globalThis.location.origin\n        } else {\n          this.#loginIframe.iframeOrigin = new URL(authUrl).origin\n        }\n        resolve()\n      })\n    })\n\n    await promise\n  }\n\n  /**\n   * @returns {Promise<boolean | undefined>}\n   */\n  async #checkLoginIframe () {\n    if (!this.#loginIframe.iframe || !this.#loginIframe.iframeOrigin) {\n      return\n    }\n\n    const message = `${this.clientId} ${(this.sessionId ? this.sessionId : '')}`\n    const origin = this.#loginIframe.iframeOrigin\n\n    /** @type {Promise<boolean>} */\n    const promise = new Promise((resolve, reject) => {\n      /** @type {(error: Error | null, value?: boolean) => void} */\n      const callback = (error, result) => error ? reject(error) : resolve(/** @type {boolean} */ (result))\n\n      this.#loginIframe.callbackList.push(callback)\n\n      if (this.#loginIframe.callbackList.length === 1) {\n        this.#loginIframe.iframe?.contentWindow?.postMessage(message, origin)\n      }\n    })\n\n    return await promise\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  async #checkSsoSilently () {\n    const iframe = document.createElement('iframe')\n    const src = await this.createLoginUrl({ prompt: 'none', redirectUri: this.silentCheckSsoRedirectUri })\n    iframe.setAttribute('src', src)\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin')\n    iframe.setAttribute('title', 'keycloak-silent-check-sso')\n    iframe.style.display = 'none'\n    document.body.appendChild(iframe)\n\n    return await new Promise((resolve, reject) => {\n      /**\n       * @param {MessageEvent} event\n       */\n      const messageCallback = async (event) => {\n        if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {\n          return\n        }\n\n        const oauth = this.#parseCallback(event.data)\n\n        try {\n          await this.#processCallback(oauth)\n          resolve()\n        } catch (error) {\n          reject(error)\n        }\n\n        document.body.removeChild(iframe)\n        window.removeEventListener('message', messageCallback)\n      }\n\n      window.addEventListener('message', messageCallback)\n    })\n  };\n\n  /**\n   * @param {string} url\n   */\n  #parseCallback (url) {\n    const oauth = this.#parseCallbackUrl(url)\n    if (!oauth) {\n      return\n    }\n\n    const oauthState = this.#callbackStorage.get(oauth.state)\n\n    if (oauthState) {\n      oauth.valid = true\n      oauth.redirectUri = oauthState.redirectUri\n      oauth.storedNonce = oauthState.nonce\n      oauth.prompt = oauthState.prompt\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier\n      oauth.loginOptions = oauthState.loginOptions\n    }\n\n    return oauth\n  }\n\n  /**\n   * @param {string} urlString\n   */\n  #parseCallbackUrl (urlString) {\n    let supportedParams = []\n    switch (this.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss']\n        break\n    }\n\n    supportedParams.push('error')\n    supportedParams.push('error_description')\n    supportedParams.push('error_uri')\n\n    const url = new URL(urlString)\n    let newUrl = ''\n    let parsed\n\n    if (this.responseMode === 'query' && url.searchParams.size > 0) {\n      parsed = this.#parseCallbackParams(url.search, supportedParams)\n      url.search = parsed.paramsString\n      newUrl = url.toString()\n    } else if (this.responseMode === 'fragment' && url.hash.length > 0) {\n      parsed = this.#parseCallbackParams(url.hash.substring(1), supportedParams)\n      url.hash = parsed.paramsString\n      newUrl = url.toString()\n    }\n\n    if (parsed?.oauthParams) {\n      if (this.flow === 'standard' || this.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.newUrl = newUrl\n          return parsed.oauthParams\n        }\n      } else if (this.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.newUrl = newUrl\n          return parsed.oauthParams\n        }\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ParsedCallbackParams\n   * @property {string} paramsString\n   * @property {Record<string, string | undefined>} oauthParams\n   */\n\n  /**\n   * @param {string} paramsString\n   * @param {string[]} supportedParams\n   * @returns {ParsedCallbackParams}\n   */\n  #parseCallbackParams (paramsString, supportedParams) {\n    const params = new URLSearchParams(paramsString)\n    /** @type {Record<string, string>} */\n    const oauthParams = {}\n\n    for (const [key, value] of Array.from(params.entries())) {\n      if (supportedParams.includes(key)) {\n        oauthParams[key] = value\n        params.delete(key)\n      }\n    }\n\n    return {\n      paramsString: params.toString(),\n      oauthParams\n    }\n  }\n\n  async #processCallback (oauth) {\n    const { code, error, prompt } = oauth\n    let timeLocal = new Date().getTime()\n\n    /**\n     * @param {string} accessToken\n     * @param {string=} refreshToken\n     * @param {string=} idToken\n     */\n    const authSuccess = (accessToken, refreshToken, idToken) => {\n      timeLocal = (timeLocal + new Date().getTime()) / 2\n\n      this.#setToken(accessToken, refreshToken, idToken, timeLocal)\n\n      if (this.#useNonce && (this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce)) {\n        this.#logInfo('[KEYCLOAK] Invalid nonce, clearing token')\n        this.clearToken()\n        throw new Error('Invalid nonce.')\n      }\n    }\n\n    if (oauth.kc_action_status) {\n      this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action)\n    }\n\n    if (error) {\n      if (prompt !== 'none') {\n        if (oauth.error_description && oauth.error_description === 'authentication_expired') {\n          await this.login(oauth.loginOptions)\n        } else {\n          const errorData = { error, error_description: oauth.error_description }\n          this.onAuthError?.(errorData)\n          throw errorData\n        }\n      }\n      return\n    } else if ((this.flow !== 'standard') && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, undefined, oauth.id_token)\n      this.onAuthSuccess?.()\n    }\n\n    if ((this.flow !== 'implicit') && code) {\n      try {\n        const response = await fetchAccessToken(this.endpoints.token(), code, /** @type {string} */ (this.clientId), oauth.redirectUri, oauth.pkceCodeVerifier)\n        authSuccess(response.access_token, response.refresh_token, response.id_token)\n\n        if (this.flow === 'standard') {\n          this.onAuthSuccess?.()\n        }\n\n        this.#scheduleCheckIframe()\n      } catch (error) {\n        this.onAuthError?.()\n        throw error\n      }\n    }\n  }\n\n  async #scheduleCheckIframe () {\n    if (this.#loginIframe.enable && this.token) {\n      await waitForTimeout(this.#loginIframe.interval * 1000)\n      const unchanged = await this.#checkLoginIframe()\n\n      if (unchanged) {\n        await this.#scheduleCheckIframe()\n      }\n    }\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<void>}\n   */\n  login = (options) => {\n    return this.#adapter.login(options)\n  }\n\n  /**\n   * @param {KeycloakLoginOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createLoginUrl = async (options) => {\n    const state = createUUID()\n    const nonce = createUUID()\n    const redirectUri = this.#adapter.redirectUri(options)\n    /** @type {CallbackState} */\n    const callbackState = {\n      state,\n      nonce,\n      redirectUri,\n      loginOptions: options\n    }\n\n    if (options?.prompt) {\n      callbackState.prompt = options.prompt\n    }\n\n    const url = options?.action === 'register'\n      ? this.endpoints.register()\n      : this.endpoints.authorize()\n\n    let scope = options?.scope || this.scope\n    const scopeValues = scope ? scope.split(' ') : []\n\n    // Ensure the 'openid' scope is always included.\n    if (!scopeValues.includes('openid')) {\n      scopeValues.unshift('openid')\n    }\n\n    scope = scopeValues.join(' ')\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      ['redirect_uri', redirectUri],\n      ['state', state],\n      ['response_mode', this.responseMode],\n      ['response_type', this.responseType],\n      ['scope', scope]\n    ])\n\n    if (this.#useNonce) {\n      params.append('nonce', nonce)\n    }\n\n    if (options?.prompt) {\n      params.append('prompt', options.prompt)\n    }\n\n    if (typeof options?.maxAge === 'number') {\n      params.append('max_age', options.maxAge.toString())\n    }\n\n    if (options?.loginHint) {\n      params.append('login_hint', options.loginHint)\n    }\n\n    if (options?.idpHint) {\n      params.append('kc_idp_hint', options.idpHint)\n    }\n\n    if (options?.action && options.action !== 'register') {\n      params.append('kc_action', options.action)\n    }\n\n    if (options?.locale) {\n      params.append('ui_locales', options.locale)\n    }\n\n    if (options?.acr) {\n      params.append('claims', buildClaimsParameter(options.acr))\n    }\n\n    if (options?.acrValues) {\n      params.append('acr_values', options.acrValues)\n    }\n\n    if (this.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96)\n        const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier)\n\n        callbackState.pkceCodeVerifier = codeVerifier\n\n        params.append('code_challenge', pkceChallenge)\n        params.append('code_challenge_method', this.pkceMethod)\n      } catch (error) {\n        throw new Error('Failed to generate PKCE challenge.', { cause: error })\n      }\n    }\n\n    this.#callbackStorage.add(callbackState)\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {Promise<void>}\n   */\n  logout = (options) => {\n    return this.#adapter.logout(options)\n  }\n\n  /**\n   * @param {KeycloakLogoutOptions} [options]\n   * @returns {string}\n   */\n  createLogoutUrl = (options) => {\n    const logoutMethod = options?.logoutMethod ?? this.logoutMethod\n    const url = this.endpoints.logout()\n\n    if (logoutMethod === 'POST') {\n      return url\n    }\n\n    const params = new URLSearchParams([\n      ['client_id', /** @type {string} */ (this.clientId)],\n      ['post_logout_redirect_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    if (this.idToken) {\n      params.append('id_token_hint', this.idToken)\n    }\n\n    return `${url}?${params.toString()}`\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<void>}\n   */\n  register = (options) => {\n    return this.#adapter.register(options)\n  }\n\n  /**\n   * @param {KeycloakRegisterOptions} [options]\n   * @returns {Promise<string>}\n   */\n  createRegisterUrl = (options) => {\n    return this.createLoginUrl({ ...options, action: 'register' })\n  }\n\n  /**\n   * @param {KeycloakAccountOptions} [options]\n   * @returns {string}\n   */\n  createAccountUrl = (options) => {\n    const url = this.#getRealmUrl()\n\n    if (!url) {\n      throw new Error('Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const params = new URLSearchParams([\n      ['referrer', /** @type {string} */ (this.clientId)],\n      ['referrer_uri', this.#adapter.redirectUri(options)]\n    ])\n\n    return `${url}/account?${params.toString()}`\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  accountManagement = () => {\n    return this.#adapter.accountManagement()\n  }\n\n  /**\n   * @param {string} role\n   * @returns {boolean}\n   */\n  hasRealmRole = (role) => {\n    const access = this.realmAccess\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @param {string} role\n   * @param {string} [resource]\n   * @returns {boolean}\n   */\n  hasResourceRole = (role, resource) => {\n    if (!this.resourceAccess) {\n      return false\n    }\n\n    const access = this.resourceAccess[resource || /** @type {string} */ (this.clientId)]\n    return !!access && access.roles.indexOf(role) >= 0\n  }\n\n  /**\n   * @returns {Promise<KeycloakProfile>}\n   */\n  loadUserProfile = async () => {\n    const realmUrl = this.#getRealmUrl()\n\n    if (!realmUrl) {\n      throw new Error('Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.')\n    }\n\n    const url = `${realmUrl}/account`\n    /** @type {KeycloakProfile} */\n    const profile = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.profile = profile)\n  }\n\n  /**\n   * @returns {Promise<{}>}\n   */\n  loadUserInfo = async () => {\n    const url = this.endpoints.userinfo()\n    /** @type {{}} */\n    const userInfo = await fetchJSON(url, {\n      headers: [buildAuthorizationHeader(this.token)]\n    })\n\n    return (this.userInfo = userInfo)\n  }\n\n  /**\n   * @param {number} [minValidity]\n   * @returns {boolean}\n   */\n  isTokenExpired = (minValidity) => {\n    if (!this.tokenParsed || (!this.refreshToken && this.flow !== 'implicit')) {\n      throw new Error('Not authenticated')\n    }\n\n    if (this.timeSkew == null) {\n      this.#logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set')\n      return true\n    }\n\n    if (typeof this.tokenParsed.exp !== 'number') {\n      return false\n    }\n\n    let expiresIn = this.tokenParsed.exp - Math.ceil(new Date().getTime() / 1000) + this.timeSkew\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw new Error('Invalid minValidity')\n      }\n      expiresIn -= minValidity\n    }\n    return expiresIn < 0\n  }\n\n  /**\n   * @param {number} minValidity\n   * @returns {Promise<boolean>}\n   */\n  updateToken = async (minValidity) => {\n    if (!this.refreshToken) {\n      throw new Error('Unable to update token, no refresh token available.')\n    }\n\n    minValidity = minValidity || 5\n\n    if (this.#loginIframe.enable) {\n      await this.#checkLoginIframe()\n    }\n\n    let refreshToken = false\n\n    if (minValidity === -1) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: forced refresh')\n    } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {\n      refreshToken = true\n      this.#logInfo('[KEYCLOAK] Refreshing token: token expired')\n    }\n\n    if (!refreshToken) {\n      return false\n    }\n\n    /** @type {PromiseWithResolvers<boolean>} */\n    const { promise, resolve, reject } = Promise.withResolvers()\n\n    this.#refreshQueue.push({ resolve, reject })\n\n    if (this.#refreshQueue.length === 1) {\n      const url = this.endpoints.token()\n      let timeLocal = new Date().getTime()\n\n      try {\n        const response = await fetchRefreshToken(url, this.refreshToken, /** @type {string} */ (this.clientId))\n        this.#logInfo('[KEYCLOAK] Token refreshed')\n\n        timeLocal = (timeLocal + new Date().getTime()) / 2\n\n        this.#setToken(response.access_token, response.refresh_token, response.id_token, timeLocal)\n\n        this.onAuthRefreshSuccess?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.resolve(true)\n        }\n      } catch (error) {\n        this.#logWarn('[KEYCLOAK] Failed to refresh token')\n\n        if (error instanceof NetworkError && error.response.status === 400) {\n          this.clearToken()\n        }\n\n        this.onAuthRefreshError?.()\n        for (let p = this.#refreshQueue.pop(); p != null; p = this.#refreshQueue.pop()) {\n          p.reject(error)\n        }\n      }\n    }\n\n    return await promise\n  }\n\n  clearToken = () => {\n    if (this.token) {\n      this.#setToken()\n      this.onAuthLogout?.()\n      if (this.loginRequired) {\n        this.login()\n      }\n    }\n  }\n\n  /**\n   * @param {string} [token]\n   * @param {string} [refreshToken]\n   * @param {string} [idToken]\n   * @param {number} [timeLocal]\n   */\n  #setToken (token, refreshToken, idToken, timeLocal) {\n    if (this.tokenTimeoutHandle) {\n      clearTimeout(this.tokenTimeoutHandle)\n      this.tokenTimeoutHandle = undefined\n    }\n\n    if (refreshToken) {\n      this.refreshToken = refreshToken\n      this.refreshTokenParsed = decodeToken(refreshToken)\n    } else {\n      delete this.refreshToken\n      delete this.refreshTokenParsed\n    }\n\n    if (idToken) {\n      this.idToken = idToken\n      this.idTokenParsed = decodeToken(idToken)\n    } else {\n      delete this.idToken\n      delete this.idTokenParsed\n    }\n\n    if (token) {\n      this.token = token\n      this.tokenParsed = decodeToken(token)\n      this.sessionId = this.tokenParsed.sid\n      this.authenticated = true\n      this.subject = this.tokenParsed.sub\n      this.realmAccess = this.tokenParsed.realm_access\n      this.resourceAccess = this.tokenParsed.resource_access\n\n      if (timeLocal) {\n        this.timeSkew = Math.floor(timeLocal / 1000) - this.tokenParsed.iat\n      }\n\n      if (this.timeSkew !== null) {\n        this.#logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + this.timeSkew + ' seconds')\n\n        if (this.onTokenExpired) {\n          const expiresIn = (this.tokenParsed.exp - (new Date().getTime() / 1000) + this.timeSkew) * 1000\n          this.#logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s')\n          if (expiresIn <= 0) {\n            this.onTokenExpired()\n          } else {\n            this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn)\n          }\n        }\n      }\n    } else {\n      delete this.token\n      delete this.tokenParsed\n      delete this.subject\n      delete this.realmAccess\n      delete this.resourceAccess\n\n      this.authenticated = false\n    }\n  }\n\n  /**\n   * @returns {string=}\n   */\n  #getRealmUrl () {\n    if (typeof this.authServerUrl === 'undefined') {\n      return\n    }\n\n    return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(/** @type {string} */ (this.realm))}`\n  }\n\n  /**\n   * @param {Function} fn\n   * @returns {(message: string) => void}\n   */\n  #createLogger (fn) {\n    return (message) => {\n      if (this.enableLogging) {\n        fn.call(console, message)\n      }\n    }\n  }\n}\n\n/**\n * @returns {string}\n */\nfunction createUUID () {\n  if (typeof crypto === 'undefined' || typeof crypto.randomUUID === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.randomUUID()\n}\n\n/**\n * @param {Acr} requestedAcr\n * @returns {string}\n */\nfunction buildClaimsParameter (requestedAcr) {\n  return JSON.stringify({\n    id_token: {\n      acr: requestedAcr\n    }\n  })\n}\n\n/**\n * @param {number} len\n * @returns {string}\n */\nfunction generateCodeVerifier (len) {\n  return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')\n}\n\n/**\n * @param {string} pkceMethod\n * @param {string} codeVerifier\n * @returns {Promise<string>}\n */\nasync function generatePkceChallenge (pkceMethod, codeVerifier) {\n  if (pkceMethod !== 'S256') {\n    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`)\n  }\n\n  // hash codeVerifier, then encode as url-safe base64 without padding\n  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier))\n  const encodedHash = bytesToBase64(hashBytes)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n\n  return encodedHash\n}\n\n/**\n * @param {number} len\n * @param {string} alphabet\n * @returns {string}\n */\nfunction generateRandomString (len, alphabet) {\n  const randomData = generateRandomData(len)\n  const chars = new Array(len)\n  for (let i = 0; i < len; i++) {\n    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length)\n  }\n  return String.fromCharCode.apply(null, chars)\n}\n\n/**\n * @param {number} len\n * @returns {Uint8Array<ArrayBuffer>}\n */\nfunction generateRandomData (len) {\n  if (typeof crypto === 'undefined' || typeof crypto.getRandomValues === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return crypto.getRandomValues(new Uint8Array(len))\n}\n\n/**\n * Function to extend existing native Promise with timeout\n *\n * @template T\n * @param {Promise<T>} promise\n * @param {number} timeout\n * @param {string} errorMessage\n * @returns {Promise<T>}\n */\nfunction applyTimeoutToPromise (promise, timeout, errorMessage) {\n  /** @type {number} */\n  let timeoutHandle\n  const timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutHandle = window.setTimeout(function () {\n      reject(new Error(errorMessage || 'Promise is not settled within timeout of ' + timeout + 'ms'))\n    }, timeout)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(function () {\n    clearTimeout(timeoutHandle)\n  })\n}\n\n/**\n * @returns {CallbackStorage}\n */\nfunction createCallbackStorage () {\n  try {\n    return new LocalStorage()\n  } catch (err) {\n    return new CookieStorage()\n  }\n}\n\nconst STORAGE_KEY_PREFIX = 'kc-callback-'\n\n/**\n * @typedef {Object} CallbackState\n * @property {string} state\n * @property {string} nonce\n * @property {string} redirectUri\n * @property {KeycloakLoginOptions} [loginOptions]\n * @property {KeycloakLoginOptions['prompt']} [prompt]\n * @property {string} [pkceCodeVerifier]\n */\n\n/**\n * @typedef {Object} CallbackStorage\n * @property {(state?: string) => CallbackState | null} get\n * @property {(state: CallbackState) => void} add\n */\n\n/**\n * @implements {CallbackStorage}\n */\nclass LocalStorage {\n  constructor () {\n    globalThis.localStorage.setItem('kc-test', 'test')\n    globalThis.localStorage.removeItem('kc-test')\n  }\n\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state\n    const value = globalThis.localStorage.getItem(key)\n\n    if (value) {\n      globalThis.localStorage.removeItem(key)\n      return JSON.parse(value)\n    }\n\n    return null\n  };\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#clearInvalidValues()\n\n    const key = STORAGE_KEY_PREFIX + state.state\n    const value = JSON.stringify({\n      ...state,\n      // Set the expiry time to 1 hour from now.\n      expires: Date.now() + (60 * 60 * 1000)\n    })\n\n    try {\n      globalThis.localStorage.setItem(key, value)\n    } catch (error) {\n      // If the storage is full, clear all known values and try again.\n      this.#clearAllValues()\n      globalThis.localStorage.setItem(key, value)\n    }\n  };\n\n  /**\n   * Clears all values from local storage that are no longer valid.\n   */\n  #clearInvalidValues () {\n    const currentTime = Date.now()\n\n    for (const [key, value] of this.#getStoredEntries()) {\n      // Attempt to parse the expiry time from the value.\n      const expiry = this.#parseExpiry(value)\n\n      // Discard the value if it is malformed or expired.\n      if (expiry === null || expiry < currentTime) {\n        globalThis.localStorage.removeItem(key)\n      }\n    }\n  }\n\n  /**\n   * Clears all known values from local storage.\n   */\n  #clearAllValues () {\n    for (const [key] of this.#getStoredEntries()) {\n      globalThis.localStorage.removeItem(key)\n    }\n  }\n\n  /**\n   * Gets all entries stored in local storage that are known to be managed by this class.\n   * @returns {[string, string][]} An array of key-value pairs.\n   */\n  #getStoredEntries () {\n    return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX))\n  }\n\n  /**\n   * Parses the expiry time from a value stored in local storage.\n   * @param {string} value\n   * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n   */\n  #parseExpiry (value) {\n    let parsedValue\n\n    // Attempt to parse the value as JSON.\n    try {\n      parsedValue = JSON.parse(value)\n    } catch (error) {\n      return null\n    }\n\n    // Attempt to extract the 'expires' property.\n    if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n      return parsedValue.expires\n    }\n\n    return null\n  }\n}\n\n/**\n * @implements {CallbackStorage}\n */\nclass CookieStorage {\n  /**\n   * @param {string} [state]\n   * @returns {CallbackState | null}\n   */\n  get (state) {\n    if (!state) {\n      return null\n    }\n\n    const value = this.#getCookie(STORAGE_KEY_PREFIX + state)\n    this.#setCookie(STORAGE_KEY_PREFIX + state, '', this.#cookieExpiration(-100))\n    if (value) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  /**\n   * @param {CallbackState} state\n   */\n  add (state) {\n    this.#setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), this.#cookieExpiration(60))\n  }\n\n  /**\n   * @param {string} key\n   * @returns\n   */\n  #getCookie (key) {\n    const name = key + '='\n    const ca = document.cookie.split(';')\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i]\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1)\n      }\n      if (c.indexOf(name) === 0) {\n        return c.substring(name.length, c.length)\n      }\n    }\n    return ''\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Date} expirationDate\n   */\n  #setCookie (key, value, expirationDate) {\n    const cookie = key + '=' + value + '; ' +\n            'expires=' + expirationDate.toUTCString() + '; '\n    document.cookie = cookie\n  }\n\n  /**\n   * @param {number} minutes\n   * @returns {Date}\n   */\n  #cookieExpiration (minutes) {\n    const exp = new Date()\n    exp.setTime(exp.getTime() + (minutes * 60 * 1000))\n    return exp\n  }\n}\n\n/**\n * @param {Uint8Array<ArrayBuffer>} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64 (bytes) {\n  const binString = String.fromCodePoint(...bytes)\n  return btoa(binString)\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest (message) {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(message)\n\n  if (typeof crypto === 'undefined' || typeof crypto.subtle === 'undefined') {\n    throw new Error('Web Crypto API is not available.')\n  }\n\n  return await crypto.subtle.digest('SHA-256', data)\n}\n\n/**\n * @param {string} token\n * @returns {KeycloakTokenParsed}\n */\nfunction decodeToken (token) {\n  const [, payload] = token.split('.')\n\n  if (typeof payload !== 'string') {\n    throw new Error('Unable to decode token, payload not found.')\n  }\n\n  let decoded\n\n  try {\n    decoded = base64UrlDecode(payload)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid Base64URL value.', { cause: error })\n  }\n\n  try {\n    return JSON.parse(decoded)\n  } catch (error) {\n    throw new Error('Unable to decode token, payload is not a valid JSON value.', { cause: error })\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode (input) {\n  let output = input\n    .replaceAll('-', '+')\n    .replaceAll('_', '/')\n\n  switch (output.length % 4) {\n    case 0:\n      break\n    case 2:\n      output += '=='\n      break\n    case 3:\n      output += '='\n      break\n    default:\n      throw new Error('Input is not of the correct length.')\n  }\n\n  try {\n    return b64DecodeUnicode(output)\n  } catch (error) {\n    return atob(output)\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode (input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase()\n\n    if (code.length < 2) {\n      code = '0' + code\n    }\n\n    return '%' + code\n  }))\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject (input) {\n  return typeof input === 'object' && input !== null\n}\n\n/**\n * @typedef {Object} JsonConfig The JSON version of the adapter configuration.\n * @property {string} auth-server-url The URL of the authentication server.\n * @property {string} realm The name of the realm.\n * @property {string} resource The name of the resource, usually the client ID.\n */\n\n/**\n * Fetch the adapter configuration from the given URL.\n * @param {string} url\n * @returns {Promise<JsonConfig>}\n */\nasync function fetchJsonConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * Fetch the OpenID configuration from the given URL.\n * @param {string} url\n * @returns {Promise<OpenIdProviderMetadata>}\n */\nasync function fetchOpenIdConfig (url) {\n  return await fetchJSON(url)\n}\n\n/**\n * @typedef {Object} AccessTokenResponse The successful token response from the authorization server, based on the {@link https://datatracker.ietf.org/doc/html/rfc6749#section-5.1 OAuth 2.0 Authorization Framework specification}.\n * @property {string} access_token The access token issued by the authorization server.\n * @property {string} token_type The type of the token issued by the authorization server.\n * @property {number} [expires_in] The lifetime in seconds of the access token.\n * @property {string} [refresh_token] The refresh token issued by the authorization server.\n * @property {string} [id_token] The ID token issued by the authorization server, if requested.\n * @property {string} [scope] The scope of the access token.\n */\n\n/**\n * Fetch the access token from the given URL.\n * @param {string} url\n * @param {string} code\n * @param {string} clientId\n * @param {string} redirectUri\n * @param {string} [pkceCodeVerifier]\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchAccessToken (url, code, clientId, redirectUri, pkceCodeVerifier) {\n  const body = new URLSearchParams([\n    ['code', code],\n    ['grant_type', 'authorization_code'],\n    ['client_id', clientId],\n    ['redirect_uri', redirectUri]\n  ])\n\n  if (pkceCodeVerifier) {\n    body.append('code_verifier', pkceCodeVerifier)\n  }\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * Fetch the refresh token from the given URL.\n * @param {string} url\n * @param {string} refreshToken\n * @param {string} clientId\n * @returns {Promise<AccessTokenResponse>}\n */\nasync function fetchRefreshToken (url, refreshToken, clientId) {\n  const body = new URLSearchParams([\n    ['grant_type', 'refresh_token'],\n    ['refresh_token', refreshToken],\n    ['client_id', clientId]\n  ])\n\n  return await fetchJSON(url, {\n    method: 'POST',\n    credentials: 'include',\n    body\n  })\n}\n\n/**\n * @template [T=unknown]\n * @param {string} url\n * @param {RequestInit} init\n * @returns {Promise<T>}\n */\nasync function fetchJSON (url, init = {}) {\n  const headers = new Headers(init.headers)\n  headers.set('Accept', CONTENT_TYPE_JSON)\n\n  const response = await fetchWithErrorHandling(url, {\n    ...init,\n    headers\n  })\n\n  return await response.json()\n}\n\n/**\n * @param {string} url\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\nasync function fetchWithErrorHandling (url, init) {\n  const response = await fetch(url, init)\n\n  if (!response.ok) {\n    throw new NetworkError('Server responded with an invalid status.', { response })\n  }\n\n  return response\n}\n\n/**\n * @param {string} [token]\n * @returns {[string, string]}\n */\nfunction buildAuthorizationHeader (token) {\n  if (!token) {\n    throw new Error('Unable to build authorization header, token is not set, make sure the user is authenticated.')\n  }\n\n  return ['Authorization', `bearer ${token}`]\n}\n\n/**\n * @param {string} url\n * @returns {string}\n */\nfunction stripTrailingSlash (url) {\n  return url.endsWith('/') ? url.slice(0, -1) : url\n}\n\n/**\n * @typedef {Object} NetworkErrorOptionsProperties\n * @property {Response} response\n * @typedef {ErrorOptions & NetworkErrorOptionsProperties} NetworkErrorOptions\n */\n\nexport class NetworkError extends Error {\n  /** @type {Response} */\n  response\n\n  /**\n   * @param {string} message\n   * @param {NetworkErrorOptions} options\n   */\n  constructor (message, options) {\n    super(message, options)\n    this.response = options.response\n  }\n}\n\n/**\n * @param {number} delay\n * @returns {Promise<void>}\n */\nconst waitForTimeout = (delay) => new Promise((resolve) => setTimeout(resolve, delay))\n"],"names":["parcelRequire","$parcel$global","globalThis","self","window","global","register","module","exports","Object","defineProperty","get","$0070b44f7a8953d5$export$2e2bcd8739ae039","set","s","enumerable","configurable","console","info","warn","enable","callbackList","interval","didInitialize","authenticated","loginRequired","responseMode","responseType","flow","timeSkew","redirectUri","silentCheckSsoRedirectUri","silentCheckSsoFallback","pkceMethod","enableLogging","logoutMethod","scope","messageReceiveTimeout","idToken","idTokenParsed","token","tokenParsed","refreshToken","refreshTokenParsed","clientId","sessionId","subject","authServerUrl","realm","realmAccess","resourceAccess","profile","userInfo","endpoints","tokenTimeoutHandle","onAuthSuccess","onAuthError","onAuthRefreshSuccess","onAuthRefreshError","onTokenExpired","onAuthLogout","onReady","onActionUpdate","config","$0070b44f7a8953d5$var$isObject","Error","property","isSecureContext","init","initOptions","$0070b44f7a8953d5$var$createCallbackStorage","$0070b44f7a8953d5$var$LocalStorage","err","$0070b44f7a8953d5$var$CookieStorage","adapter","adapters","includes","useNonce","checkLoginIframe","checkLoginIframeInterval","onLoad","TypeError","type","options","location","href","login","assign","createLoginUrl","Promise","logout","replace","createLogoutUrl","form","document","createElement","name","value","setAttribute","style","display","entries","id_token_hint","client_id","post_logout_redirect_uri","input","appendChild","body","submit","createRegisterUrl","accountManagement","accountUrl","createAccountUrl","cordovaOpenWindowWrapper","loginUrl","target","cordova","InAppBrowser","open","createCordovaOptions","userOptions","cordovaOptions","keys","reduce","optionName","prompt","hidden","push","join","getCordovaRedirectUri","ref","completed","closed","closeBrowser","close","resolve","reject","addEventListener","event","url","indexOf","callback","error","clearToken","promise","oauth","universalLinks","subscribe","unsubscribe","plugins","browsertab","openUrl","logoutUrl","registerUrl","jsonConfig","$0070b44f7a8953d5$var$fetchJsonConfig","resource","oidcProvider","authorize","checkSessionIframe","thirdPartyCookiesIframe","userinfo","$0070b44f7a8953d5$var$stripTrailingSlash","openIdConfig","$0070b44f7a8953d5$var$fetchOpenIdConfig","authorization_endpoint","token_endpoint","end_session_endpoint","check_session_iframe","userinfo_endpoint","timeout","timeoutHandle","iframe","messageCallback","contentWindow","source","data","undefined","removeChild","removeEventListener","race","setTimeout","finally","clearTimeout","newUrl","history","replaceState","state","valid","doLogin","locale","updateToken","origin","iframeOrigin","callbacks","reverse","authUrl","startsWith","URL","message","result","length","postMessage","src","oauthState","storedNonce","nonce","pkceCodeVerifier","loginOptions","urlString","parsed","supportedParams","searchParams","size","search","paramsString","toString","hash","substring","oauthParams","code","access_token","params","URLSearchParams","key","Array","from","delete","timeLocal","Date","getTime","authSuccess","accessToken","kc_action_status","kc_action","error_description","errorData","id_token","response","$0070b44f7a8953d5$var$fetchAccessToken","refresh_token","$0070b44f7a8953d5$var$waitForTimeout","unchanged","$0070b44f7a8953d5$var$createUUID","callbackState","action","scopeValues","split","unshift","append","maxAge","loginHint","idpHint","acr","JSON","stringify","acrValues","codeVerifier","$0070b44f7a8953d5$var$generateCodeVerifier","len","alphabet","randomData","$0070b44f7a8953d5$var$generateRandomData","crypto","getRandomValues","Uint8Array","chars","i","charCodeAt","String","fromCharCode","apply","pkceChallenge","$0070b44f7a8953d5$var$generatePkceChallenge","cause","add","hasRealmRole","role","access","roles","hasResourceRole","loadUserProfile","realmUrl","$0070b44f7a8953d5$var$fetchJSON","headers","$0070b44f7a8953d5$var$buildAuthorizationHeader","loadUserInfo","isTokenExpired","minValidity","exp","expiresIn","Math","ceil","isNaN","withResolvers","$0070b44f7a8953d5$var$fetchRefreshToken","p","pop","$0070b44f7a8953d5$export$bae979e68e4dc802","status","$0070b44f7a8953d5$var$decodeToken","sid","sub","realm_access","resource_access","floor","iat","round","encodeURIComponent","fn","call","randomUUID","$0070b44f7a8953d5$var$bytesToBase64","btoa","fromCodePoint","$0070b44f7a8953d5$var$sha256Digest","$0070b44f7a8953d5$var$STORAGE_KEY_PREFIX","localStorage","setItem","removeItem","getItem","parse","expires","now","currentTime","expiry","filter","parsedValue","ca","cookie","c","charAt","expirationDate","toUTCString","minutes","setTime","encoder","TextEncoder","encode","subtle","digest","decoded","payload","$0070b44f7a8953d5$var$base64UrlDecode","output","replaceAll","decodeURIComponent","atob","m","toUpperCase","method","credentials","Headers","$0070b44f7a8953d5$var$fetchWithErrorHandling","json","fetch","ok","endsWith","slice","delay"],"version":3,"file":"keycloak.1ffe3714.js.map"}