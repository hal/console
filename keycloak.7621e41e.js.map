{"mappings":"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","sources":["<anon>","node_modules/keycloak-js/lib/keycloak.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire25b9\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"02lid\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $0070b44f7a8953d5$export$2e2bcd8739ae039; });\n/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function $0070b44f7a8953d5$var$Keycloak(config) {\n    if (!(this instanceof $0070b44f7a8953d5$var$Keycloak)) throw new Error(\"The 'Keycloak' constructor must be invoked with 'new'.\");\n    if (typeof config !== 'string' && !$0070b44f7a8953d5$var$isObject(config)) throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n    if ($0070b44f7a8953d5$var$isObject(config)) {\n        const requiredProperties = 'oidcProvider' in config ? [\n            'clientId'\n        ] : [\n            'url',\n            'realm',\n            'clientId'\n        ];\n        for (const property of requiredProperties){\n            if (!config[property]) throw new Error(`The configuration object is missing the required '${property}' property.`);\n        }\n    }\n    var kc = this;\n    var adapter;\n    var refreshQueue = [];\n    var callbackStorage;\n    var loginIframe = {\n        enable: true,\n        callbackList: [],\n        interval: 5\n    };\n    kc.didInitialize = false;\n    var useNonce = true;\n    var logInfo = createLogger(console.info);\n    var logWarn = createLogger(console.warn);\n    if (!globalThis.isSecureContext) logWarn(\"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\nContinuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\nFor more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\");\n    kc.init = function(initOptions = {}) {\n        if (kc.didInitialize) throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n        kc.didInitialize = true;\n        kc.authenticated = false;\n        callbackStorage = createCallbackStorage();\n        var adapters = [\n            'default',\n            'cordova',\n            'cordova-native'\n        ];\n        if (adapters.indexOf(initOptions.adapter) > -1) adapter = loadAdapter(initOptions.adapter);\n        else if (typeof initOptions.adapter === \"object\") adapter = initOptions.adapter;\n        else if (window.Cordova || window.cordova) adapter = loadAdapter('cordova');\n        else adapter = loadAdapter();\n        if (typeof initOptions.useNonce !== 'undefined') useNonce = initOptions.useNonce;\n        if (typeof initOptions.checkLoginIframe !== 'undefined') loginIframe.enable = initOptions.checkLoginIframe;\n        if (initOptions.checkLoginIframeInterval) loginIframe.interval = initOptions.checkLoginIframeInterval;\n        if (initOptions.onLoad === 'login-required') kc.loginRequired = true;\n        if (initOptions.responseMode) {\n            if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') kc.responseMode = initOptions.responseMode;\n            else throw 'Invalid value for responseMode';\n        }\n        if (initOptions.flow) {\n            switch(initOptions.flow){\n                case 'standard':\n                    kc.responseType = 'code';\n                    break;\n                case 'implicit':\n                    kc.responseType = 'id_token token';\n                    break;\n                case 'hybrid':\n                    kc.responseType = 'code id_token token';\n                    break;\n                default:\n                    throw 'Invalid value for flow';\n            }\n            kc.flow = initOptions.flow;\n        }\n        if (initOptions.timeSkew != null) kc.timeSkew = initOptions.timeSkew;\n        if (initOptions.redirectUri) kc.redirectUri = initOptions.redirectUri;\n        if (initOptions.silentCheckSsoRedirectUri) kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n        if (typeof initOptions.silentCheckSsoFallback === 'boolean') kc.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n        else kc.silentCheckSsoFallback = true;\n        if (typeof initOptions.pkceMethod !== \"undefined\") {\n            if (initOptions.pkceMethod !== \"S256\" && initOptions.pkceMethod !== false) throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n            kc.pkceMethod = initOptions.pkceMethod;\n        } else kc.pkceMethod = \"S256\";\n        if (typeof initOptions.enableLogging === 'boolean') kc.enableLogging = initOptions.enableLogging;\n        else kc.enableLogging = false;\n        if (initOptions.logoutMethod === 'POST') kc.logoutMethod = 'POST';\n        else kc.logoutMethod = 'GET';\n        if (typeof initOptions.scope === 'string') kc.scope = initOptions.scope;\n        if (typeof initOptions.acrValues === 'string') kc.acrValues = initOptions.acrValues;\n        if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) kc.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n        else kc.messageReceiveTimeout = 10000;\n        if (!kc.responseMode) kc.responseMode = 'fragment';\n        if (!kc.responseType) {\n            kc.responseType = 'code';\n            kc.flow = 'standard';\n        }\n        var promise = createPromise();\n        var initPromise = createPromise();\n        initPromise.promise.then(function() {\n            kc.onReady && kc.onReady(kc.authenticated);\n            promise.setSuccess(kc.authenticated);\n        }).catch(function(error) {\n            promise.setError(error);\n        });\n        var configPromise = loadConfig();\n        function onLoad() {\n            var doLogin = function(prompt) {\n                if (!prompt) options.prompt = 'none';\n                if (initOptions.locale) options.locale = initOptions.locale;\n                kc.login(options).then(function() {\n                    initPromise.setSuccess();\n                }).catch(function(error) {\n                    initPromise.setError(error);\n                });\n            };\n            var checkSsoSilently = async function() {\n                var ifrm = document.createElement(\"iframe\");\n                var src = await kc.createLoginUrl({\n                    prompt: 'none',\n                    redirectUri: kc.silentCheckSsoRedirectUri\n                });\n                ifrm.setAttribute(\"src\", src);\n                ifrm.setAttribute(\"sandbox\", \"allow-storage-access-by-user-activation allow-scripts allow-same-origin\");\n                ifrm.setAttribute(\"title\", \"keycloak-silent-check-sso\");\n                ifrm.style.display = \"none\";\n                document.body.appendChild(ifrm);\n                var messageCallback = function(event) {\n                    if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) return;\n                    var oauth = parseCallback(event.data);\n                    processCallback(oauth, initPromise);\n                    document.body.removeChild(ifrm);\n                    window.removeEventListener(\"message\", messageCallback);\n                };\n                window.addEventListener(\"message\", messageCallback);\n            };\n            var options = {};\n            switch(initOptions.onLoad){\n                case 'check-sso':\n                    if (loginIframe.enable) setupCheckLoginIframe().then(function() {\n                        checkLoginIframe().then(function(unchanged) {\n                            if (!unchanged) kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                            else initPromise.setSuccess();\n                        }).catch(function(error) {\n                            initPromise.setError(error);\n                        });\n                    });\n                    else kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                    break;\n                case 'login-required':\n                    doLogin(true);\n                    break;\n                default:\n                    throw 'Invalid value for onLoad';\n            }\n        }\n        function processInit() {\n            var callback = parseCallback(window.location.href);\n            if (callback) window.history.replaceState(window.history.state, null, callback.newUrl);\n            if (callback && callback.valid) return setupCheckLoginIframe().then(function() {\n                processCallback(callback, initPromise);\n            }).catch(function(error) {\n                initPromise.setError(error);\n            });\n            if (initOptions.token && initOptions.refreshToken) {\n                setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n                if (loginIframe.enable) setupCheckLoginIframe().then(function() {\n                    checkLoginIframe().then(function(unchanged) {\n                        if (unchanged) {\n                            kc.onAuthSuccess && kc.onAuthSuccess();\n                            initPromise.setSuccess();\n                            scheduleCheckIframe();\n                        } else initPromise.setSuccess();\n                    }).catch(function(error) {\n                        initPromise.setError(error);\n                    });\n                });\n                else kc.updateToken(-1).then(function() {\n                    kc.onAuthSuccess && kc.onAuthSuccess();\n                    initPromise.setSuccess();\n                }).catch(function(error) {\n                    kc.onAuthError && kc.onAuthError();\n                    if (initOptions.onLoad) onLoad();\n                    else initPromise.setError(error);\n                });\n            } else if (initOptions.onLoad) onLoad();\n            else initPromise.setSuccess();\n        }\n        configPromise.then(function() {\n            check3pCookiesSupported().then(processInit).catch(function(error) {\n                promise.setError(error);\n            });\n        });\n        configPromise.catch(function(error) {\n            promise.setError(error);\n        });\n        return promise.promise;\n    };\n    kc.login = function(options) {\n        return adapter.login(options);\n    };\n    function generateRandomData(len) {\n        if (typeof crypto === \"undefined\" || typeof crypto.getRandomValues === \"undefined\") throw new Error(\"Web Crypto API is not available.\");\n        return crypto.getRandomValues(new Uint8Array(len));\n    }\n    function generateCodeVerifier(len) {\n        return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n    function generateRandomString(len, alphabet) {\n        var randomData = generateRandomData(len);\n        var chars = new Array(len);\n        for(var i = 0; i < len; i++)chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n        return String.fromCharCode.apply(null, chars);\n    }\n    async function generatePkceChallenge(pkceMethod, codeVerifier) {\n        if (pkceMethod !== \"S256\") throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n        // hash codeVerifier, then encode as url-safe base64 without padding\n        const hashBytes = new Uint8Array(await $0070b44f7a8953d5$var$sha256Digest(codeVerifier));\n        const encodedHash = $0070b44f7a8953d5$var$bytesToBase64(hashBytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n        return encodedHash;\n    }\n    function buildClaimsParameter(requestedAcr) {\n        var claims = {\n            id_token: {\n                acr: requestedAcr\n            }\n        };\n        return JSON.stringify(claims);\n    }\n    kc.createLoginUrl = async function(options) {\n        var state = createUUID();\n        var nonce = createUUID();\n        var redirectUri = adapter.redirectUri(options);\n        var callbackState = {\n            state: state,\n            nonce: nonce,\n            redirectUri: encodeURIComponent(redirectUri),\n            loginOptions: options\n        };\n        if (options && options.prompt) callbackState.prompt = options.prompt;\n        var baseUrl;\n        if (options && options.action == 'register') baseUrl = kc.endpoints.register();\n        else baseUrl = kc.endpoints.authorize();\n        var scope = options && options.scope || kc.scope;\n        if (!scope) // if scope is not set, default to \"openid\"\n        scope = \"openid\";\n        else if (scope.indexOf(\"openid\") === -1) // if openid scope is missing, prefix the given scopes with it\n        scope = \"openid \" + scope;\n        var url = baseUrl + '?client_id=' + encodeURIComponent(kc.clientId) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&state=' + encodeURIComponent(state) + '&response_mode=' + encodeURIComponent(kc.responseMode) + '&response_type=' + encodeURIComponent(kc.responseType) + '&scope=' + encodeURIComponent(scope);\n        if (useNonce) url = url + '&nonce=' + encodeURIComponent(nonce);\n        if (options && options.prompt) url += '&prompt=' + encodeURIComponent(options.prompt);\n        if (options && typeof options.maxAge === 'number') url += '&max_age=' + encodeURIComponent(options.maxAge);\n        if (options && options.loginHint) url += '&login_hint=' + encodeURIComponent(options.loginHint);\n        if (options && options.idpHint) url += '&kc_idp_hint=' + encodeURIComponent(options.idpHint);\n        if (options && options.action && options.action != 'register') url += '&kc_action=' + encodeURIComponent(options.action);\n        if (options && options.locale) url += '&ui_locales=' + encodeURIComponent(options.locale);\n        if (options && options.acr) {\n            var claimsParameter = buildClaimsParameter(options.acr);\n            url += '&claims=' + encodeURIComponent(claimsParameter);\n        }\n        if (options && options.acrValues || kc.acrValues) url += '&acr_values=' + encodeURIComponent(options.acrValues || kc.acrValues);\n        if (kc.pkceMethod) try {\n            const codeVerifier = generateCodeVerifier(96);\n            const pkceChallenge = await generatePkceChallenge(kc.pkceMethod, codeVerifier);\n            callbackState.pkceCodeVerifier = codeVerifier;\n            url += '&code_challenge=' + pkceChallenge;\n            url += '&code_challenge_method=' + kc.pkceMethod;\n        } catch (error) {\n            throw new Error(\"Failed to generate PKCE challenge.\", {\n                cause: error\n            });\n        }\n        callbackStorage.add(callbackState);\n        return url;\n    };\n    kc.logout = function(options) {\n        return adapter.logout(options);\n    };\n    kc.createLogoutUrl = function(options) {\n        const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n        if (logoutMethod === 'POST') return kc.endpoints.logout();\n        var url = kc.endpoints.logout() + '?client_id=' + encodeURIComponent(kc.clientId) + '&post_logout_redirect_uri=' + encodeURIComponent(adapter.redirectUri(options, false));\n        if (kc.idToken) url += '&id_token_hint=' + encodeURIComponent(kc.idToken);\n        return url;\n    };\n    kc.register = function(options) {\n        return adapter.register(options);\n    };\n    kc.createRegisterUrl = async function(options) {\n        if (!options) options = {};\n        options.action = 'register';\n        return await kc.createLoginUrl(options);\n    };\n    kc.createAccountUrl = function(options) {\n        var realm = getRealmUrl();\n        var url = undefined;\n        if (typeof realm !== 'undefined') url = realm + '/account' + '?referrer=' + encodeURIComponent(kc.clientId) + '&referrer_uri=' + encodeURIComponent(adapter.redirectUri(options));\n        return url;\n    };\n    kc.accountManagement = function() {\n        return adapter.accountManagement();\n    };\n    kc.hasRealmRole = function(role) {\n        var access = kc.realmAccess;\n        return !!access && access.roles.indexOf(role) >= 0;\n    };\n    kc.hasResourceRole = function(role, resource) {\n        if (!kc.resourceAccess) return false;\n        var access = kc.resourceAccess[resource || kc.clientId];\n        return !!access && access.roles.indexOf(role) >= 0;\n    };\n    kc.loadUserProfile = function() {\n        var url = getRealmUrl() + '/account';\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n        var promise = createPromise();\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.profile = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.profile);\n                } else promise.setError();\n            }\n        };\n        req.send();\n        return promise.promise;\n    };\n    kc.loadUserInfo = function() {\n        var url = kc.endpoints.userinfo();\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n        var promise = createPromise();\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.userInfo = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.userInfo);\n                } else promise.setError();\n            }\n        };\n        req.send();\n        return promise.promise;\n    };\n    kc.isTokenExpired = function(minValidity) {\n        if (!kc.tokenParsed || !kc.refreshToken && kc.flow != 'implicit') throw 'Not authenticated';\n        if (kc.timeSkew == null) {\n            logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n            return true;\n        }\n        var expiresIn = kc.tokenParsed['exp'] - Math.ceil(new Date().getTime() / 1000) + kc.timeSkew;\n        if (minValidity) {\n            if (isNaN(minValidity)) throw 'Invalid minValidity';\n            expiresIn -= minValidity;\n        }\n        return expiresIn < 0;\n    };\n    kc.updateToken = function(minValidity) {\n        var promise = createPromise();\n        if (!kc.refreshToken) {\n            promise.setError();\n            return promise.promise;\n        }\n        minValidity = minValidity || 5;\n        var exec = function() {\n            var refreshToken = false;\n            if (minValidity == -1) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n            } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: token expired');\n            }\n            if (!refreshToken) promise.setSuccess(false);\n            else {\n                var params = \"grant_type=refresh_token&refresh_token=\" + kc.refreshToken;\n                var url = kc.endpoints.token();\n                refreshQueue.push(promise);\n                if (refreshQueue.length == 1) {\n                    var req = new XMLHttpRequest();\n                    req.open('POST', url, true);\n                    req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n                    req.withCredentials = true;\n                    params += '&client_id=' + encodeURIComponent(kc.clientId);\n                    var timeLocal = new Date().getTime();\n                    req.onreadystatechange = function() {\n                        if (req.readyState == 4) {\n                            if (req.status == 200) {\n                                logInfo('[KEYCLOAK] Token refreshed');\n                                timeLocal = (timeLocal + new Date().getTime()) / 2;\n                                var tokenResponse = JSON.parse(req.responseText);\n                                setToken(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], timeLocal);\n                                kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();\n                                for(var p = refreshQueue.pop(); p != null; p = refreshQueue.pop())p.setSuccess(true);\n                            } else {\n                                logWarn('[KEYCLOAK] Failed to refresh token');\n                                if (req.status == 400) kc.clearToken();\n                                kc.onAuthRefreshError && kc.onAuthRefreshError();\n                                for(var p = refreshQueue.pop(); p != null; p = refreshQueue.pop())p.setError(\"Failed to refresh token: An unexpected HTTP error occurred while attempting to refresh the token.\");\n                            }\n                        }\n                    };\n                    req.send(params);\n                }\n            }\n        };\n        if (loginIframe.enable) {\n            var iframePromise = checkLoginIframe();\n            iframePromise.then(function() {\n                exec();\n            }).catch(function(error) {\n                promise.setError(error);\n            });\n        } else exec();\n        return promise.promise;\n    };\n    kc.clearToken = function() {\n        if (kc.token) {\n            setToken(null, null, null);\n            kc.onAuthLogout && kc.onAuthLogout();\n            if (kc.loginRequired) kc.login();\n        }\n    };\n    function getRealmUrl() {\n        if (typeof kc.authServerUrl !== 'undefined') {\n            if (kc.authServerUrl.charAt(kc.authServerUrl.length - 1) == '/') return kc.authServerUrl + 'realms/' + encodeURIComponent(kc.realm);\n            else return kc.authServerUrl + '/realms/' + encodeURIComponent(kc.realm);\n        } else return undefined;\n    }\n    function getOrigin() {\n        if (!window.location.origin) return window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n        else return window.location.origin;\n    }\n    function processCallback(oauth, promise) {\n        var code = oauth.code;\n        var error = oauth.error;\n        var prompt = oauth.prompt;\n        var timeLocal = new Date().getTime();\n        if (oauth['kc_action_status']) kc.onActionUpdate && kc.onActionUpdate(oauth['kc_action_status'], oauth['kc_action']);\n        if (error) {\n            if (prompt != 'none') {\n                if (oauth.error_description && oauth.error_description === \"authentication_expired\") kc.login(oauth.loginOptions);\n                else {\n                    var errorData = {\n                        error: error,\n                        error_description: oauth.error_description\n                    };\n                    kc.onAuthError && kc.onAuthError(errorData);\n                    promise && promise.setError(errorData);\n                }\n            } else promise && promise.setSuccess();\n            return;\n        } else if (kc.flow != 'standard' && (oauth.access_token || oauth.id_token)) authSuccess(oauth.access_token, null, oauth.id_token, true);\n        if (kc.flow != 'implicit' && code) {\n            var params = 'code=' + code + '&grant_type=authorization_code';\n            var url = kc.endpoints.token();\n            var req = new XMLHttpRequest();\n            req.open('POST', url, true);\n            req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n            params += '&client_id=' + encodeURIComponent(kc.clientId);\n            params += '&redirect_uri=' + oauth.redirectUri;\n            if (oauth.pkceCodeVerifier) params += '&code_verifier=' + oauth.pkceCodeVerifier;\n            req.withCredentials = true;\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200) {\n                        var tokenResponse = JSON.parse(req.responseText);\n                        authSuccess(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], kc.flow === 'standard');\n                        scheduleCheckIframe();\n                    } else {\n                        kc.onAuthError && kc.onAuthError();\n                        promise && promise.setError();\n                    }\n                }\n            };\n            req.send(params);\n        }\n        function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {\n            timeLocal = (timeLocal + new Date().getTime()) / 2;\n            setToken(accessToken, refreshToken, idToken, timeLocal);\n            if (useNonce && kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce) {\n                logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n                kc.clearToken();\n                promise && promise.setError();\n            } else if (fulfillPromise) {\n                kc.onAuthSuccess && kc.onAuthSuccess();\n                promise && promise.setSuccess();\n            }\n        }\n    }\n    function loadConfig() {\n        var promise = createPromise();\n        var configUrl;\n        if (typeof config === 'string') configUrl = config;\n        function setupOidcEndoints(oidcConfiguration) {\n            if (!oidcConfiguration) kc.endpoints = {\n                authorize: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/auth';\n                },\n                token: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/token';\n                },\n                logout: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/logout';\n                },\n                checkSessionIframe: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n                },\n                thirdPartyCookiesIframe: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n                },\n                register: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/registrations';\n                },\n                userinfo: function() {\n                    return getRealmUrl() + '/protocol/openid-connect/userinfo';\n                }\n            };\n            else kc.endpoints = {\n                authorize: function() {\n                    return oidcConfiguration.authorization_endpoint;\n                },\n                token: function() {\n                    return oidcConfiguration.token_endpoint;\n                },\n                logout: function() {\n                    if (!oidcConfiguration.end_session_endpoint) throw \"Not supported by the OIDC server\";\n                    return oidcConfiguration.end_session_endpoint;\n                },\n                checkSessionIframe: function() {\n                    if (!oidcConfiguration.check_session_iframe) throw \"Not supported by the OIDC server\";\n                    return oidcConfiguration.check_session_iframe;\n                },\n                register: function() {\n                    throw 'Redirection to \"Register user\" page not supported in standard OIDC mode';\n                },\n                userinfo: function() {\n                    if (!oidcConfiguration.userinfo_endpoint) throw \"Not supported by the OIDC server\";\n                    return oidcConfiguration.userinfo_endpoint;\n                }\n            };\n        }\n        if (configUrl) {\n            var req = new XMLHttpRequest();\n            req.open('GET', configUrl, true);\n            req.setRequestHeader('Accept', 'application/json');\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || fileLoaded(req)) {\n                        var config = JSON.parse(req.responseText);\n                        kc.authServerUrl = config['auth-server-url'];\n                        kc.realm = config['realm'];\n                        kc.clientId = config['resource'];\n                        setupOidcEndoints(null);\n                        promise.setSuccess();\n                    } else promise.setError();\n                }\n            };\n            req.send();\n        } else {\n            kc.clientId = config.clientId;\n            var oidcProvider = config['oidcProvider'];\n            if (!oidcProvider) {\n                kc.authServerUrl = config.url;\n                kc.realm = config.realm;\n                setupOidcEndoints(null);\n                promise.setSuccess();\n            } else if (typeof oidcProvider === 'string') {\n                var oidcProviderConfigUrl;\n                if (oidcProvider.charAt(oidcProvider.length - 1) == '/') oidcProviderConfigUrl = oidcProvider + '.well-known/openid-configuration';\n                else oidcProviderConfigUrl = oidcProvider + '/.well-known/openid-configuration';\n                var req = new XMLHttpRequest();\n                req.open('GET', oidcProviderConfigUrl, true);\n                req.setRequestHeader('Accept', 'application/json');\n                req.onreadystatechange = function() {\n                    if (req.readyState == 4) {\n                        if (req.status == 200 || fileLoaded(req)) {\n                            var oidcProviderConfig = JSON.parse(req.responseText);\n                            setupOidcEndoints(oidcProviderConfig);\n                            promise.setSuccess();\n                        } else promise.setError();\n                    }\n                };\n                req.send();\n            } else {\n                setupOidcEndoints(oidcProvider);\n                promise.setSuccess();\n            }\n        }\n        return promise.promise;\n    }\n    function fileLoaded(xhr) {\n        return xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith('file:');\n    }\n    function setToken(token, refreshToken, idToken, timeLocal) {\n        if (kc.tokenTimeoutHandle) {\n            clearTimeout(kc.tokenTimeoutHandle);\n            kc.tokenTimeoutHandle = null;\n        }\n        if (refreshToken) {\n            kc.refreshToken = refreshToken;\n            kc.refreshTokenParsed = $0070b44f7a8953d5$var$decodeToken(refreshToken);\n        } else {\n            delete kc.refreshToken;\n            delete kc.refreshTokenParsed;\n        }\n        if (idToken) {\n            kc.idToken = idToken;\n            kc.idTokenParsed = $0070b44f7a8953d5$var$decodeToken(idToken);\n        } else {\n            delete kc.idToken;\n            delete kc.idTokenParsed;\n        }\n        if (token) {\n            kc.token = token;\n            kc.tokenParsed = $0070b44f7a8953d5$var$decodeToken(token);\n            kc.sessionId = kc.tokenParsed.sid;\n            kc.authenticated = true;\n            kc.subject = kc.tokenParsed.sub;\n            kc.realmAccess = kc.tokenParsed.realm_access;\n            kc.resourceAccess = kc.tokenParsed.resource_access;\n            if (timeLocal) kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat;\n            if (kc.timeSkew != null) {\n                logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + kc.timeSkew + ' seconds');\n                if (kc.onTokenExpired) {\n                    var expiresIn = (kc.tokenParsed['exp'] - new Date().getTime() / 1000 + kc.timeSkew) * 1000;\n                    logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n                    if (expiresIn <= 0) kc.onTokenExpired();\n                    else kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, expiresIn);\n                }\n            }\n        } else {\n            delete kc.token;\n            delete kc.tokenParsed;\n            delete kc.subject;\n            delete kc.realmAccess;\n            delete kc.resourceAccess;\n            kc.authenticated = false;\n        }\n    }\n    function createUUID() {\n        if (typeof crypto === \"undefined\" || typeof crypto.randomUUID === \"undefined\") throw new Error(\"Web Crypto API is not available.\");\n        return crypto.randomUUID();\n    }\n    function parseCallback(url) {\n        var oauth = parseCallbackUrl(url);\n        if (!oauth) return;\n        var oauthState = callbackStorage.get(oauth.state);\n        if (oauthState) {\n            oauth.valid = true;\n            oauth.redirectUri = oauthState.redirectUri;\n            oauth.storedNonce = oauthState.nonce;\n            oauth.prompt = oauthState.prompt;\n            oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n            oauth.loginOptions = oauthState.loginOptions;\n        }\n        return oauth;\n    }\n    function parseCallbackUrl(url) {\n        var supportedParams;\n        switch(kc.flow){\n            case 'standard':\n                supportedParams = [\n                    'code',\n                    'state',\n                    'session_state',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n            case 'implicit':\n                supportedParams = [\n                    'access_token',\n                    'token_type',\n                    'id_token',\n                    'state',\n                    'session_state',\n                    'expires_in',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n            case 'hybrid':\n                supportedParams = [\n                    'access_token',\n                    'token_type',\n                    'id_token',\n                    'code',\n                    'state',\n                    'session_state',\n                    'expires_in',\n                    'kc_action_status',\n                    'kc_action',\n                    'iss'\n                ];\n                break;\n        }\n        supportedParams.push('error');\n        supportedParams.push('error_description');\n        supportedParams.push('error_uri');\n        var queryIndex = url.indexOf('?');\n        var fragmentIndex = url.indexOf('#');\n        var newUrl;\n        var parsed;\n        if (kc.responseMode === 'query' && queryIndex !== -1) {\n            newUrl = url.substring(0, queryIndex);\n            parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);\n            if (parsed.paramsString !== '') newUrl += '?' + parsed.paramsString;\n            if (fragmentIndex !== -1) newUrl += url.substring(fragmentIndex);\n        } else if (kc.responseMode === 'fragment' && fragmentIndex !== -1) {\n            newUrl = url.substring(0, fragmentIndex);\n            parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);\n            if (parsed.paramsString !== '') newUrl += '#' + parsed.paramsString;\n        }\n        if (parsed && parsed.oauthParams) {\n            if (kc.flow === 'standard' || kc.flow === 'hybrid') {\n                if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            } else if (kc.flow === 'implicit') {\n                if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            }\n        }\n    }\n    function parseCallbackParams(paramsString, supportedParams) {\n        var p = paramsString.split('&');\n        var result = {\n            paramsString: '',\n            oauthParams: {}\n        };\n        for(var i = 0; i < p.length; i++){\n            var split = p[i].indexOf(\"=\");\n            var key = p[i].slice(0, split);\n            if (supportedParams.indexOf(key) !== -1) result.oauthParams[key] = p[i].slice(split + 1);\n            else {\n                if (result.paramsString !== '') result.paramsString += '&';\n                result.paramsString += p[i];\n            }\n        }\n        return result;\n    }\n    function createPromise() {\n        // Need to create a native Promise which also preserves the\n        // interface of the custom promise type previously used by the API\n        var p = {\n            setSuccess: function(result) {\n                p.resolve(result);\n            },\n            setError: function(result) {\n                p.reject(result);\n            }\n        };\n        p.promise = new Promise(function(resolve, reject) {\n            p.resolve = resolve;\n            p.reject = reject;\n        });\n        return p;\n    }\n    // Function to extend existing native Promise with timeout\n    function applyTimeoutToPromise(promise, timeout, errorMessage) {\n        var timeoutHandle = null;\n        var timeoutPromise = new Promise(function(resolve, reject) {\n            timeoutHandle = setTimeout(function() {\n                reject({\n                    \"error\": errorMessage || \"Promise is not settled within timeout of \" + timeout + \"ms\"\n                });\n            }, timeout);\n        });\n        return Promise.race([\n            promise,\n            timeoutPromise\n        ]).finally(function() {\n            clearTimeout(timeoutHandle);\n        });\n    }\n    function setupCheckLoginIframe() {\n        var promise = createPromise();\n        if (!loginIframe.enable) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n        if (loginIframe.iframe) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n        var iframe = document.createElement('iframe');\n        loginIframe.iframe = iframe;\n        iframe.onload = function() {\n            var authUrl = kc.endpoints.authorize();\n            if (authUrl.charAt(0) === '/') loginIframe.iframeOrigin = getOrigin();\n            else loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf('/', 8));\n            promise.setSuccess();\n        };\n        var src = kc.endpoints.checkSessionIframe();\n        iframe.setAttribute('src', src);\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-session-iframe');\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        var messageCallback = function(event) {\n            if (event.origin !== loginIframe.iframeOrigin || loginIframe.iframe.contentWindow !== event.source) return;\n            if (!(event.data == 'unchanged' || event.data == 'changed' || event.data == 'error')) return;\n            if (event.data != 'unchanged') kc.clearToken();\n            var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);\n            for(var i = callbacks.length - 1; i >= 0; --i){\n                var promise = callbacks[i];\n                if (event.data == 'error') promise.setError();\n                else promise.setSuccess(event.data == 'unchanged');\n            }\n        };\n        window.addEventListener('message', messageCallback, false);\n        return promise.promise;\n    }\n    function scheduleCheckIframe() {\n        if (loginIframe.enable) {\n            if (kc.token) setTimeout(function() {\n                checkLoginIframe().then(function(unchanged) {\n                    if (unchanged) scheduleCheckIframe();\n                });\n            }, loginIframe.interval * 1000);\n        }\n    }\n    function checkLoginIframe() {\n        var promise = createPromise();\n        if (loginIframe.iframe && loginIframe.iframeOrigin) {\n            var msg = kc.clientId + ' ' + (kc.sessionId ? kc.sessionId : '');\n            loginIframe.callbackList.push(promise);\n            var origin = loginIframe.iframeOrigin;\n            if (loginIframe.callbackList.length == 1) loginIframe.iframe.contentWindow.postMessage(msg, origin);\n        } else promise.setSuccess();\n        return promise.promise;\n    }\n    function check3pCookiesSupported() {\n        var promise = createPromise();\n        if ((loginIframe.enable || kc.silentCheckSsoRedirectUri) && typeof kc.endpoints.thirdPartyCookiesIframe === 'function') {\n            var iframe = document.createElement('iframe');\n            iframe.setAttribute('src', kc.endpoints.thirdPartyCookiesIframe());\n            iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n            iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n            iframe.style.display = 'none';\n            document.body.appendChild(iframe);\n            var messageCallback = function(event) {\n                if (iframe.contentWindow !== event.source) return;\n                if (event.data !== \"supported\" && event.data !== \"unsupported\") return;\n                else if (event.data === \"unsupported\") {\n                    logWarn(\"[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\nFor more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers\");\n                    loginIframe.enable = false;\n                    if (kc.silentCheckSsoFallback) kc.silentCheckSsoRedirectUri = false;\n                }\n                document.body.removeChild(iframe);\n                window.removeEventListener(\"message\", messageCallback);\n                promise.setSuccess();\n            };\n            window.addEventListener('message', messageCallback, false);\n        } else promise.setSuccess();\n        return applyTimeoutToPromise(promise.promise, kc.messageReceiveTimeout, \"Timeout when waiting for 3rd party check iframe message.\");\n    }\n    function loadAdapter(type) {\n        if (!type || type == 'default') return {\n            login: async function(options) {\n                window.location.assign(await kc.createLoginUrl(options));\n                return createPromise().promise;\n            },\n            logout: async function(options) {\n                const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n                if (logoutMethod === \"GET\") {\n                    window.location.replace(kc.createLogoutUrl(options));\n                    return;\n                }\n                // Create form to send POST request.\n                const form = document.createElement(\"form\");\n                form.setAttribute(\"method\", \"POST\");\n                form.setAttribute(\"action\", kc.createLogoutUrl(options));\n                form.style.display = \"none\";\n                // Add data to form as hidden input fields.\n                const data = {\n                    id_token_hint: kc.idToken,\n                    client_id: kc.clientId,\n                    post_logout_redirect_uri: adapter.redirectUri(options, false)\n                };\n                for (const [name, value] of Object.entries(data)){\n                    const input = document.createElement(\"input\");\n                    input.setAttribute(\"type\", \"hidden\");\n                    input.setAttribute(\"name\", name);\n                    input.setAttribute(\"value\", value);\n                    form.appendChild(input);\n                }\n                // Append form to page and submit it to perform logout and redirect.\n                document.body.appendChild(form);\n                form.submit();\n            },\n            register: async function(options) {\n                window.location.assign(await kc.createRegisterUrl(options));\n                return createPromise().promise;\n            },\n            accountManagement: function() {\n                var accountUrl = kc.createAccountUrl();\n                if (typeof accountUrl !== 'undefined') window.location.href = accountUrl;\n                else throw \"Not supported by the OIDC server\";\n                return createPromise().promise;\n            },\n            redirectUri: function(options, encodeHash) {\n                if (arguments.length == 1) encodeHash = true;\n                if (options && options.redirectUri) return options.redirectUri;\n                else if (kc.redirectUri) return kc.redirectUri;\n                else return location.href;\n            }\n        };\n        if (type == 'cordova') {\n            loginIframe.enable = false;\n            var cordovaOpenWindowWrapper = function(loginUrl, target, options) {\n                if (window.cordova && window.cordova.InAppBrowser) // Use inappbrowser for IOS and Android if available\n                return window.cordova.InAppBrowser.open(loginUrl, target, options);\n                else return window.open(loginUrl, target, options);\n            };\n            var shallowCloneCordovaOptions = function(userOptions) {\n                if (userOptions && userOptions.cordovaOptions) return Object.keys(userOptions.cordovaOptions).reduce(function(options, optionName) {\n                    options[optionName] = userOptions.cordovaOptions[optionName];\n                    return options;\n                }, {});\n                else return {};\n            };\n            var formatCordovaOptions = function(cordovaOptions) {\n                return Object.keys(cordovaOptions).reduce(function(options, optionName) {\n                    options.push(optionName + \"=\" + cordovaOptions[optionName]);\n                    return options;\n                }, []).join(\",\");\n            };\n            var createCordovaOptions = function(userOptions) {\n                var cordovaOptions = shallowCloneCordovaOptions(userOptions);\n                cordovaOptions.location = 'no';\n                if (userOptions && userOptions.prompt == 'none') cordovaOptions.hidden = 'yes';\n                return formatCordovaOptions(cordovaOptions);\n            };\n            var getCordovaRedirectUri = function() {\n                return kc.redirectUri || 'http://localhost';\n            };\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n                    var cordovaOptions = createCordovaOptions(options);\n                    var loginUrl = await kc.createLoginUrl(options);\n                    var ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n                    var completed = false;\n                    var closed = false;\n                    var closeBrowser = function() {\n                        closed = true;\n                        ref.close();\n                    };\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            var callback = parseCallback(event.url);\n                            processCallback(callback, promise);\n                            closeBrowser();\n                            completed = true;\n                        }\n                    });\n                    ref.addEventListener('loaderror', function(event) {\n                        if (!completed) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                                var callback = parseCallback(event.url);\n                                processCallback(callback, promise);\n                                closeBrowser();\n                                completed = true;\n                            } else {\n                                promise.setError();\n                                closeBrowser();\n                            }\n                        }\n                    });\n                    ref.addEventListener('exit', function(event) {\n                        if (!closed) promise.setError({\n                            reason: \"closed_by_user\"\n                        });\n                    });\n                    return promise.promise;\n                },\n                logout: function(options) {\n                    var promise = createPromise();\n                    var logoutUrl = kc.createLogoutUrl(options);\n                    var ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n                    var error;\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) ref.close();\n                    });\n                    ref.addEventListener('loaderror', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) ref.close();\n                        else {\n                            error = true;\n                            ref.close();\n                        }\n                    });\n                    ref.addEventListener('exit', function(event) {\n                        if (error) promise.setError();\n                        else {\n                            kc.clearToken();\n                            promise.setSuccess();\n                        }\n                    });\n                    return promise.promise;\n                },\n                register: async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl();\n                    var cordovaOptions = createCordovaOptions(options);\n                    var ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                            var oauth = parseCallback(event.url);\n                            processCallback(oauth, promise);\n                        }\n                    });\n                    return promise.promise;\n                },\n                accountManagement: function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        var ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n                        ref.addEventListener('loadstart', function(event) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) ref.close();\n                        });\n                    } else throw \"Not supported by the OIDC server\";\n                },\n                redirectUri: function(options) {\n                    return getCordovaRedirectUri();\n                }\n            };\n        }\n        if (type == 'cordova-native') {\n            loginIframe.enable = false;\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n                    var loginUrl = await kc.createLoginUrl(options);\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n                    window.cordova.plugins.browsertab.openUrl(loginUrl);\n                    return promise.promise;\n                },\n                logout: function(options) {\n                    var promise = createPromise();\n                    var logoutUrl = kc.createLogoutUrl(options);\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        kc.clearToken();\n                        promise.setSuccess();\n                    });\n                    window.cordova.plugins.browsertab.openUrl(logoutUrl);\n                    return promise.promise;\n                },\n                register: async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl(options);\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n                    window.cordova.plugins.browsertab.openUrl(registerUrl);\n                    return promise.promise;\n                },\n                accountManagement: function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') window.cordova.plugins.browsertab.openUrl(accountUrl);\n                    else throw \"Not supported by the OIDC server\";\n                },\n                redirectUri: function(options) {\n                    if (options && options.redirectUri) return options.redirectUri;\n                    else if (kc.redirectUri) return kc.redirectUri;\n                    else return \"http://localhost\";\n                }\n            };\n        }\n        throw 'invalid adapter type: ' + type;\n    }\n    const STORAGE_KEY_PREFIX = 'kc-callback-';\n    var LocalStorage = function() {\n        if (!(this instanceof LocalStorage)) return new LocalStorage();\n        localStorage.setItem('kc-test', 'test');\n        localStorage.removeItem('kc-test');\n        var cs = this;\n        /**\n         * Clears all values from local storage that are no longer valid.\n         */ function clearInvalidValues() {\n            const currentTime = Date.now();\n            for (const [key, value] of getStoredEntries()){\n                // Attempt to parse the expiry time from the value.\n                const expiry = parseExpiry(value);\n                // Discard the value if it is malformed or expired.\n                if (expiry === null || expiry < currentTime) localStorage.removeItem(key);\n            }\n        }\n        /**\n         * Clears all known values from local storage.\n         */ function clearAllValues() {\n            for (const [key] of getStoredEntries())localStorage.removeItem(key);\n        }\n        /**\n         * Gets all entries stored in local storage that are known to be managed by this class.\n         * @returns {Array<[string, unknown]>} An array of key-value pairs.\n         */ function getStoredEntries() {\n            return Object.entries(localStorage).filter(([key])=>key.startsWith(STORAGE_KEY_PREFIX));\n        }\n        /**\n         * Parses the expiry time from a value stored in local storage.\n         * @param {unknown} value\n         * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n         */ function parseExpiry(value) {\n            let parsedValue;\n            // Attempt to parse the value as JSON.\n            try {\n                parsedValue = JSON.parse(value);\n            } catch (error) {\n                return null;\n            }\n            // Attempt to extract the 'expires' property.\n            if ($0070b44f7a8953d5$var$isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') return parsedValue.expires;\n            return null;\n        }\n        cs.get = function(state) {\n            if (!state) return;\n            var key = STORAGE_KEY_PREFIX + state;\n            var value = localStorage.getItem(key);\n            if (value) {\n                localStorage.removeItem(key);\n                value = JSON.parse(value);\n            }\n            clearInvalidValues();\n            return value;\n        };\n        cs.add = function(state) {\n            clearInvalidValues();\n            const key = STORAGE_KEY_PREFIX + state.state;\n            const value = JSON.stringify({\n                ...state,\n                // Set the expiry time to 1 hour from now.\n                expires: Date.now() + 3600000\n            });\n            try {\n                localStorage.setItem(key, value);\n            } catch (error) {\n                // If the storage is full, clear all known values and try again.\n                clearAllValues();\n                localStorage.setItem(key, value);\n            }\n        };\n    };\n    var CookieStorage = function() {\n        if (!(this instanceof CookieStorage)) return new CookieStorage();\n        var cs = this;\n        cs.get = function(state) {\n            if (!state) return;\n            var value = getCookie(STORAGE_KEY_PREFIX + state);\n            setCookie(STORAGE_KEY_PREFIX + state, '', cookieExpiration(-100));\n            if (value) return JSON.parse(value);\n        };\n        cs.add = function(state) {\n            setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), cookieExpiration(60));\n        };\n        cs.removeItem = function(key) {\n            setCookie(key, '', cookieExpiration(-100));\n        };\n        var cookieExpiration = function(minutes) {\n            var exp = new Date();\n            exp.setTime(exp.getTime() + minutes * 60000);\n            return exp;\n        };\n        var getCookie = function(key) {\n            var name = key + '=';\n            var ca = document.cookie.split(';');\n            for(var i = 0; i < ca.length; i++){\n                var c = ca[i];\n                while(c.charAt(0) == ' ')c = c.substring(1);\n                if (c.indexOf(name) == 0) return c.substring(name.length, c.length);\n            }\n            return '';\n        };\n        var setCookie = function(key, value, expirationDate) {\n            var cookie = key + '=' + value + '; ' + 'expires=' + expirationDate.toUTCString() + '; ';\n            document.cookie = cookie;\n        };\n    };\n    function createCallbackStorage() {\n        try {\n            return new LocalStorage();\n        } catch (err) {}\n        return new CookieStorage();\n    }\n    function createLogger(fn) {\n        return function() {\n            if (kc.enableLogging) fn.apply(console, Array.prototype.slice.call(arguments));\n        };\n    }\n}\nvar $0070b44f7a8953d5$export$2e2bcd8739ae039 = $0070b44f7a8953d5$var$Keycloak;\n/**\n * @param {ArrayBuffer} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */ function $0070b44f7a8953d5$var$bytesToBase64(bytes) {\n    const binString = String.fromCodePoint(...bytes);\n    return btoa(binString);\n}\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */ async function $0070b44f7a8953d5$var$sha256Digest(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n    if (typeof crypto === \"undefined\" || typeof crypto.subtle === \"undefined\") throw new Error(\"Web Crypto API is not available.\");\n    return await crypto.subtle.digest(\"SHA-256\", data);\n}\n/**\n * @param {string} token\n */ function $0070b44f7a8953d5$var$decodeToken(token) {\n    const [header, payload] = token.split(\".\");\n    if (typeof payload !== \"string\") throw new Error(\"Unable to decode token, payload not found.\");\n    let decoded;\n    try {\n        decoded = $0070b44f7a8953d5$var$base64UrlDecode(payload);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid Base64URL value.\", {\n            cause: error\n        });\n    }\n    try {\n        return JSON.parse(decoded);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid JSON value.\", {\n            cause: error\n        });\n    }\n}\n/**\n * @param {string} input\n */ function $0070b44f7a8953d5$var$base64UrlDecode(input) {\n    let output = input.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n    switch(output.length % 4){\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"Input is not of the correct length.\");\n    }\n    try {\n        return $0070b44f7a8953d5$var$b64DecodeUnicode(output);\n    } catch (error) {\n        return atob(output);\n    }\n}\n/**\n * @param {string} input\n */ function $0070b44f7a8953d5$var$b64DecodeUnicode(input) {\n    return decodeURIComponent(atob(input).replace(/(.)/g, (m, p)=>{\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) code = \"0\" + code;\n        return \"%\" + code;\n    }));\n}\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */ function $0070b44f7a8953d5$var$isObject(input) {\n    return typeof input === 'object' && input !== null;\n}\n\n});\n\n\n//# sourceMappingURL=keycloak.7621e41e.js.map\n","/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction Keycloak (config) {\n    if (!(this instanceof Keycloak)) {\n        throw new Error(\"The 'Keycloak' constructor must be invoked with 'new'.\")\n    }\n\n    if (typeof config !== 'string' && !isObject(config)) {\n        throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n    }\n\n    if (isObject(config)) {\n        const requiredProperties = 'oidcProvider' in config\n            ? ['clientId']\n            : ['url', 'realm', 'clientId'];\n\n        for (const property of requiredProperties) {\n            if (!config[property]) {\n                throw new Error(`The configuration object is missing the required '${property}' property.`);\n            }\n        }\n    }\n\n    var kc = this;\n    var adapter;\n    var refreshQueue = [];\n    var callbackStorage;\n\n    var loginIframe = {\n        enable: true,\n        callbackList: [],\n        interval: 5\n    };\n\n    kc.didInitialize = false;\n\n    var useNonce = true;\n    var logInfo = createLogger(console.info);\n    var logWarn = createLogger(console.warn);\n\n    if (!globalThis.isSecureContext) {\n        logWarn(\n            \"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" +\n            \"Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n\" +\n            \"For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\"\n        );\n    }\n\n    kc.init = function (initOptions = {}) {\n        if (kc.didInitialize) {\n            throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n        }\n\n        kc.didInitialize = true;\n\n        kc.authenticated = false;\n\n        callbackStorage = createCallbackStorage();\n        var adapters = ['default', 'cordova', 'cordova-native'];\n\n        if (adapters.indexOf(initOptions.adapter) > -1) {\n            adapter = loadAdapter(initOptions.adapter);\n        } else if (typeof initOptions.adapter === \"object\") {\n            adapter = initOptions.adapter;\n        } else {\n            if (window.Cordova || window.cordova) {\n                adapter = loadAdapter('cordova');\n            } else {\n                adapter = loadAdapter();\n            }\n        }\n\n        if (typeof initOptions.useNonce !== 'undefined') {\n            useNonce = initOptions.useNonce;\n        }\n\n        if (typeof initOptions.checkLoginIframe !== 'undefined') {\n            loginIframe.enable = initOptions.checkLoginIframe;\n        }\n\n        if (initOptions.checkLoginIframeInterval) {\n            loginIframe.interval = initOptions.checkLoginIframeInterval;\n        }\n\n        if (initOptions.onLoad === 'login-required') {\n            kc.loginRequired = true;\n        }\n\n        if (initOptions.responseMode) {\n            if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n                kc.responseMode = initOptions.responseMode;\n            } else {\n                throw 'Invalid value for responseMode';\n            }\n        }\n\n        if (initOptions.flow) {\n            switch (initOptions.flow) {\n                case 'standard':\n                    kc.responseType = 'code';\n                    break;\n                case 'implicit':\n                    kc.responseType = 'id_token token';\n                    break;\n                case 'hybrid':\n                    kc.responseType = 'code id_token token';\n                    break;\n                default:\n                    throw 'Invalid value for flow';\n            }\n            kc.flow = initOptions.flow;\n        }\n\n        if (initOptions.timeSkew != null) {\n            kc.timeSkew = initOptions.timeSkew;\n        }\n\n        if(initOptions.redirectUri) {\n            kc.redirectUri = initOptions.redirectUri;\n        }\n\n        if (initOptions.silentCheckSsoRedirectUri) {\n            kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n        }\n\n        if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n            kc.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n        } else {\n            kc.silentCheckSsoFallback = true;\n        }\n\n        if (typeof initOptions.pkceMethod !== \"undefined\") {\n            if (initOptions.pkceMethod !== \"S256\" && initOptions.pkceMethod !== false) {\n                throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n            }\n\n            kc.pkceMethod = initOptions.pkceMethod;\n        } else {\n            kc.pkceMethod = \"S256\";\n        }\n\n        if (typeof initOptions.enableLogging === 'boolean') {\n            kc.enableLogging = initOptions.enableLogging;\n        } else {\n            kc.enableLogging = false;\n        }\n\n        if (initOptions.logoutMethod === 'POST') {\n            kc.logoutMethod = 'POST';\n        } else {\n            kc.logoutMethod = 'GET';\n        }\n\n        if (typeof initOptions.scope === 'string') {\n            kc.scope = initOptions.scope;\n        }\n\n        if (typeof initOptions.acrValues === 'string') {\n            kc.acrValues = initOptions.acrValues;\n        }\n\n        if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n            kc.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n        } else {\n            kc.messageReceiveTimeout = 10000;\n        }\n\n        if (!kc.responseMode) {\n            kc.responseMode = 'fragment';\n        }\n        if (!kc.responseType) {\n            kc.responseType = 'code';\n            kc.flow = 'standard';\n        }\n\n        var promise = createPromise();\n\n        var initPromise = createPromise();\n        initPromise.promise.then(function() {\n            kc.onReady && kc.onReady(kc.authenticated);\n            promise.setSuccess(kc.authenticated);\n        }).catch(function(error) {\n            promise.setError(error);\n        });\n\n        var configPromise = loadConfig();\n\n        function onLoad() {\n            var doLogin = function(prompt) {\n                if (!prompt) {\n                    options.prompt = 'none';\n                }\n\n                if (initOptions.locale) {\n                    options.locale = initOptions.locale;\n                }\n                kc.login(options).then(function () {\n                    initPromise.setSuccess();\n                }).catch(function (error) {\n                    initPromise.setError(error);\n                });\n            }\n\n            var checkSsoSilently = async function() {\n                var ifrm = document.createElement(\"iframe\");\n                var src = await kc.createLoginUrl({prompt: 'none', redirectUri: kc.silentCheckSsoRedirectUri});\n                ifrm.setAttribute(\"src\", src);\n                ifrm.setAttribute(\"sandbox\", \"allow-storage-access-by-user-activation allow-scripts allow-same-origin\");\n                ifrm.setAttribute(\"title\", \"keycloak-silent-check-sso\");\n                ifrm.style.display = \"none\";\n                document.body.appendChild(ifrm);\n\n                var messageCallback = function(event) {\n                    if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) {\n                        return;\n                    }\n\n                    var oauth = parseCallback(event.data);\n                    processCallback(oauth, initPromise);\n\n                    document.body.removeChild(ifrm);\n                    window.removeEventListener(\"message\", messageCallback);\n                };\n\n                window.addEventListener(\"message\", messageCallback);\n            };\n\n            var options = {};\n            switch (initOptions.onLoad) {\n                case 'check-sso':\n                    if (loginIframe.enable) {\n                        setupCheckLoginIframe().then(function() {\n                            checkLoginIframe().then(function (unchanged) {\n                                if (!unchanged) {\n                                    kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                                } else {\n                                    initPromise.setSuccess();\n                                }\n                            }).catch(function (error) {\n                                initPromise.setError(error);\n                            });\n                        });\n                    } else {\n                        kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                    }\n                    break;\n                case 'login-required':\n                    doLogin(true);\n                    break;\n                default:\n                    throw 'Invalid value for onLoad';\n            }\n        }\n\n        function processInit() {\n            var callback = parseCallback(window.location.href);\n\n            if (callback) {\n                window.history.replaceState(window.history.state, null, callback.newUrl);\n            }\n\n            if (callback && callback.valid) {\n                return setupCheckLoginIframe().then(function() {\n                    processCallback(callback, initPromise);\n                }).catch(function (error) {\n                    initPromise.setError(error);\n                });\n            }\n\n            if (initOptions.token && initOptions.refreshToken) {\n                setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n\n                if (loginIframe.enable) {\n                    setupCheckLoginIframe().then(function() {\n                        checkLoginIframe().then(function (unchanged) {\n                            if (unchanged) {\n                                kc.onAuthSuccess && kc.onAuthSuccess();\n                                initPromise.setSuccess();\n                                scheduleCheckIframe();\n                            } else {\n                                initPromise.setSuccess();\n                            }\n                        }).catch(function (error) {\n                            initPromise.setError(error);\n                        });\n                    });\n                } else {\n                    kc.updateToken(-1).then(function() {\n                        kc.onAuthSuccess && kc.onAuthSuccess();\n                        initPromise.setSuccess();\n                    }).catch(function(error) {\n                        kc.onAuthError && kc.onAuthError();\n                        if (initOptions.onLoad) {\n                            onLoad();\n                        } else {\n                            initPromise.setError(error);\n                        }\n                    });\n                }\n            } else if (initOptions.onLoad) {\n                onLoad();\n            } else {\n                initPromise.setSuccess();\n            }\n        }\n\n        configPromise.then(function () {\n            check3pCookiesSupported()\n                .then(processInit)\n                .catch(function (error) {\n                    promise.setError(error);\n                });\n        });\n        configPromise.catch(function (error) {\n            promise.setError(error);\n        });\n\n        return promise.promise;\n    }\n\n    kc.login = function (options) {\n        return adapter.login(options);\n    }\n\n    function generateRandomData(len) {\n        if (typeof crypto === \"undefined\" || typeof crypto.getRandomValues === \"undefined\") {\n            throw new Error(\"Web Crypto API is not available.\");\n        }\n\n        return crypto.getRandomValues(new Uint8Array(len));\n    }\n\n    function generateCodeVerifier(len) {\n        return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n    }\n\n    function generateRandomString(len, alphabet){\n        var randomData = generateRandomData(len);\n        var chars = new Array(len);\n        for (var i = 0; i < len; i++) {\n            chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n        }\n        return String.fromCharCode.apply(null, chars);\n    }\n\n    async function generatePkceChallenge(pkceMethod, codeVerifier) {\n        if (pkceMethod !== \"S256\") {\n            throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n        }\n\n        // hash codeVerifier, then encode as url-safe base64 without padding\n        const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));\n        const encodedHash = bytesToBase64(hashBytes)\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/\\=/g, '');\n\n        return encodedHash;\n    }\n\n    function buildClaimsParameter(requestedAcr){\n        var claims = {\n            id_token: {\n                acr: requestedAcr\n            }\n        }\n        return JSON.stringify(claims);\n    }\n\n    kc.createLoginUrl = async function(options) {\n        var state = createUUID();\n        var nonce = createUUID();\n\n        var redirectUri = adapter.redirectUri(options);\n\n        var callbackState = {\n            state: state,\n            nonce: nonce,\n            redirectUri: encodeURIComponent(redirectUri),\n            loginOptions: options\n        };\n\n        if (options && options.prompt) {\n            callbackState.prompt = options.prompt;\n        }\n\n        var baseUrl;\n        if (options && options.action == 'register') {\n            baseUrl = kc.endpoints.register();\n        } else {\n            baseUrl = kc.endpoints.authorize();\n        }\n\n        var scope = options && options.scope || kc.scope;\n        if (!scope) {\n            // if scope is not set, default to \"openid\"\n            scope = \"openid\";\n        } else if (scope.indexOf(\"openid\") === -1) {\n            // if openid scope is missing, prefix the given scopes with it\n            scope = \"openid \" + scope;\n        }\n\n        var url = baseUrl\n            + '?client_id=' + encodeURIComponent(kc.clientId)\n            + '&redirect_uri=' + encodeURIComponent(redirectUri)\n            + '&state=' + encodeURIComponent(state)\n            + '&response_mode=' + encodeURIComponent(kc.responseMode)\n            + '&response_type=' + encodeURIComponent(kc.responseType)\n            + '&scope=' + encodeURIComponent(scope);\n        if (useNonce) {\n            url = url + '&nonce=' + encodeURIComponent(nonce);\n        }\n\n        if (options && options.prompt) {\n            url += '&prompt=' + encodeURIComponent(options.prompt);\n        }\n\n        if (options && typeof options.maxAge === 'number') {\n            url += '&max_age=' + encodeURIComponent(options.maxAge);\n        }\n\n        if (options && options.loginHint) {\n            url += '&login_hint=' + encodeURIComponent(options.loginHint);\n        }\n\n        if (options && options.idpHint) {\n            url += '&kc_idp_hint=' + encodeURIComponent(options.idpHint);\n        }\n\n        if (options && options.action && options.action != 'register') {\n            url += '&kc_action=' + encodeURIComponent(options.action);\n        }\n\n        if (options && options.locale) {\n            url += '&ui_locales=' + encodeURIComponent(options.locale);\n        }\n\n        if (options && options.acr) {\n            var claimsParameter = buildClaimsParameter(options.acr);\n            url += '&claims=' + encodeURIComponent(claimsParameter);\n        }\n\n        if ((options && options.acrValues) || kc.acrValues) {\n            url += '&acr_values=' + encodeURIComponent(options.acrValues || kc.acrValues);\n        }\n\n        if (kc.pkceMethod) {\n            try {\n                const codeVerifier = generateCodeVerifier(96);\n                const pkceChallenge = await generatePkceChallenge(kc.pkceMethod, codeVerifier);\n\n                callbackState.pkceCodeVerifier = codeVerifier;\n\n                url += '&code_challenge=' + pkceChallenge;\n                url += '&code_challenge_method=' + kc.pkceMethod;\n            } catch (error) {\n                throw new Error(\"Failed to generate PKCE challenge.\", { cause: error });\n            }\n        }\n\n        callbackStorage.add(callbackState);\n\n        return url;\n    }\n\n    kc.logout = function(options) {\n        return adapter.logout(options);\n    }\n\n    kc.createLogoutUrl = function(options) {\n\n        const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n        if (logoutMethod === 'POST') {\n            return kc.endpoints.logout();\n        }\n\n        var url = kc.endpoints.logout()\n            + '?client_id=' + encodeURIComponent(kc.clientId)\n            + '&post_logout_redirect_uri=' + encodeURIComponent(adapter.redirectUri(options, false));\n\n        if (kc.idToken) {\n            url += '&id_token_hint=' + encodeURIComponent(kc.idToken);\n        }\n\n        return url;\n    }\n\n    kc.register = function (options) {\n        return adapter.register(options);\n    }\n\n    kc.createRegisterUrl = async function(options) {\n        if (!options) {\n            options = {};\n        }\n        options.action = 'register';\n        return await kc.createLoginUrl(options);\n    }\n\n    kc.createAccountUrl = function(options) {\n        var realm = getRealmUrl();\n        var url = undefined;\n        if (typeof realm !== 'undefined') {\n            url = realm\n            + '/account'\n            + '?referrer=' + encodeURIComponent(kc.clientId)\n            + '&referrer_uri=' + encodeURIComponent(adapter.redirectUri(options));\n        }\n        return url;\n    }\n\n    kc.accountManagement = function() {\n        return adapter.accountManagement();\n    }\n\n    kc.hasRealmRole = function (role) {\n        var access = kc.realmAccess;\n        return !!access && access.roles.indexOf(role) >= 0;\n    }\n\n    kc.hasResourceRole = function(role, resource) {\n        if (!kc.resourceAccess) {\n            return false;\n        }\n\n        var access = kc.resourceAccess[resource || kc.clientId];\n        return !!access && access.roles.indexOf(role) >= 0;\n    }\n\n    kc.loadUserProfile = function() {\n        var url = getRealmUrl() + '/account';\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n\n        var promise = createPromise();\n\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.profile = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.profile);\n                } else {\n                    promise.setError();\n                }\n            }\n        }\n\n        req.send();\n\n        return promise.promise;\n    }\n\n    kc.loadUserInfo = function() {\n        var url = kc.endpoints.userinfo();\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n\n        var promise = createPromise();\n\n        req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n                if (req.status == 200) {\n                    kc.userInfo = JSON.parse(req.responseText);\n                    promise.setSuccess(kc.userInfo);\n                } else {\n                    promise.setError();\n                }\n            }\n        }\n\n        req.send();\n\n        return promise.promise;\n    }\n\n    kc.isTokenExpired = function(minValidity) {\n        if (!kc.tokenParsed || (!kc.refreshToken && kc.flow != 'implicit' )) {\n            throw 'Not authenticated';\n        }\n\n        if (kc.timeSkew == null) {\n            logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n            return true;\n        }\n\n        var expiresIn = kc.tokenParsed['exp'] - Math.ceil(new Date().getTime() / 1000) + kc.timeSkew;\n        if (minValidity) {\n            if (isNaN(minValidity)) {\n                throw 'Invalid minValidity';\n            }\n            expiresIn -= minValidity;\n        }\n        return expiresIn < 0;\n    }\n\n    kc.updateToken = function(minValidity) {\n        var promise = createPromise();\n\n        if (!kc.refreshToken) {\n            promise.setError();\n            return promise.promise;\n        }\n\n        minValidity = minValidity || 5;\n\n        var exec = function() {\n            var refreshToken = false;\n            if (minValidity == -1) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n            } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {\n                refreshToken = true;\n                logInfo('[KEYCLOAK] Refreshing token: token expired');\n            }\n\n            if (!refreshToken) {\n                promise.setSuccess(false);\n            } else {\n                var params = 'grant_type=refresh_token&' + 'refresh_token=' + kc.refreshToken;\n                var url = kc.endpoints.token();\n\n                refreshQueue.push(promise);\n\n                if (refreshQueue.length == 1) {\n                    var req = new XMLHttpRequest();\n                    req.open('POST', url, true);\n                    req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n                    req.withCredentials = true;\n\n                    params += '&client_id=' + encodeURIComponent(kc.clientId);\n\n                    var timeLocal = new Date().getTime();\n\n                    req.onreadystatechange = function () {\n                        if (req.readyState == 4) {\n                            if (req.status == 200) {\n                                logInfo('[KEYCLOAK] Token refreshed');\n\n                                timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n                                var tokenResponse = JSON.parse(req.responseText);\n\n                                setToken(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], timeLocal);\n\n                                kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();\n                                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                                    p.setSuccess(true);\n                                }\n                            } else {\n                                logWarn('[KEYCLOAK] Failed to refresh token');\n\n                                if (req.status == 400) {\n                                    kc.clearToken();\n                                }\n\n                                kc.onAuthRefreshError && kc.onAuthRefreshError();\n                                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                                    p.setError(\"Failed to refresh token: An unexpected HTTP error occurred while attempting to refresh the token.\");\n                                }\n                            }\n                        }\n                    };\n\n                    req.send(params);\n                }\n            }\n        }\n\n        if (loginIframe.enable) {\n            var iframePromise = checkLoginIframe();\n            iframePromise.then(function() {\n                exec();\n            }).catch(function(error) {\n                promise.setError(error);\n            });\n        } else {\n            exec();\n        }\n\n        return promise.promise;\n    }\n\n    kc.clearToken = function() {\n        if (kc.token) {\n            setToken(null, null, null);\n            kc.onAuthLogout && kc.onAuthLogout();\n            if (kc.loginRequired) {\n                kc.login();\n            }\n        }\n    }\n\n    function getRealmUrl() {\n        if (typeof kc.authServerUrl !== 'undefined') {\n            if (kc.authServerUrl.charAt(kc.authServerUrl.length - 1) == '/') {\n                return kc.authServerUrl + 'realms/' + encodeURIComponent(kc.realm);\n            } else {\n                return kc.authServerUrl + '/realms/' + encodeURIComponent(kc.realm);\n            }\n        } else {\n            return undefined;\n        }\n    }\n\n    function getOrigin() {\n        if (!window.location.origin) {\n            return window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');\n        } else {\n            return window.location.origin;\n        }\n    }\n\n    function processCallback(oauth, promise) {\n        var code = oauth.code;\n        var error = oauth.error;\n        var prompt = oauth.prompt;\n\n        var timeLocal = new Date().getTime();\n\n        if (oauth['kc_action_status']) {\n            kc.onActionUpdate && kc.onActionUpdate(oauth['kc_action_status'], oauth['kc_action']);\n        }\n\n        if (error) {\n            if (prompt != 'none') {\n                if (oauth.error_description && oauth.error_description === \"authentication_expired\") {\n                    kc.login(oauth.loginOptions);\n                } else {\n                    var errorData = { error: error, error_description: oauth.error_description };\n                    kc.onAuthError && kc.onAuthError(errorData);\n                    promise && promise.setError(errorData);\n                }\n            } else {\n                promise && promise.setSuccess();\n            }\n            return;\n        } else if ((kc.flow != 'standard') && (oauth.access_token || oauth.id_token)) {\n            authSuccess(oauth.access_token, null, oauth.id_token, true);\n        }\n\n        if ((kc.flow != 'implicit') && code) {\n            var params = 'code=' + code + '&grant_type=authorization_code';\n            var url = kc.endpoints.token();\n\n            var req = new XMLHttpRequest();\n            req.open('POST', url, true);\n            req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n            params += '&client_id=' + encodeURIComponent(kc.clientId);\n            params += '&redirect_uri=' + oauth.redirectUri;\n\n            if (oauth.pkceCodeVerifier) {\n                params += '&code_verifier=' + oauth.pkceCodeVerifier;\n            }\n\n            req.withCredentials = true;\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200) {\n\n                        var tokenResponse = JSON.parse(req.responseText);\n                        authSuccess(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], kc.flow === 'standard');\n                        scheduleCheckIframe();\n                    } else {\n                        kc.onAuthError && kc.onAuthError();\n                        promise && promise.setError();\n                    }\n                }\n            };\n\n            req.send(params);\n        }\n\n        function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {\n            timeLocal = (timeLocal + new Date().getTime()) / 2;\n\n            setToken(accessToken, refreshToken, idToken, timeLocal);\n\n            if (useNonce && (kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce)) {\n                logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n                kc.clearToken();\n                promise && promise.setError();\n            } else {\n                if (fulfillPromise) {\n                    kc.onAuthSuccess && kc.onAuthSuccess();\n                    promise && promise.setSuccess();\n                }\n            }\n        }\n\n    }\n\n    function loadConfig() {\n        var promise = createPromise();\n        var configUrl;\n\n        if (typeof config === 'string') {\n            configUrl = config;\n        }\n\n        function setupOidcEndoints(oidcConfiguration) {\n            if (! oidcConfiguration) {\n                kc.endpoints = {\n                    authorize: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/auth';\n                    },\n                    token: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/token';\n                    },\n                    logout: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/logout';\n                    },\n                    checkSessionIframe: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n                    },\n                    thirdPartyCookiesIframe: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n                    },\n                    register: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/registrations';\n                    },\n                    userinfo: function() {\n                        return getRealmUrl() + '/protocol/openid-connect/userinfo';\n                    }\n                };\n            } else {\n                kc.endpoints = {\n                    authorize: function() {\n                        return oidcConfiguration.authorization_endpoint;\n                    },\n                    token: function() {\n                        return oidcConfiguration.token_endpoint;\n                    },\n                    logout: function() {\n                        if (!oidcConfiguration.end_session_endpoint) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.end_session_endpoint;\n                    },\n                    checkSessionIframe: function() {\n                        if (!oidcConfiguration.check_session_iframe) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.check_session_iframe;\n                    },\n                    register: function() {\n                        throw 'Redirection to \"Register user\" page not supported in standard OIDC mode';\n                    },\n                    userinfo: function() {\n                        if (!oidcConfiguration.userinfo_endpoint) {\n                            throw \"Not supported by the OIDC server\";\n                        }\n                        return oidcConfiguration.userinfo_endpoint;\n                    }\n                }\n            }\n        }\n\n        if (configUrl) {\n            var req = new XMLHttpRequest();\n            req.open('GET', configUrl, true);\n            req.setRequestHeader('Accept', 'application/json');\n\n            req.onreadystatechange = function () {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || fileLoaded(req)) {\n                        var config = JSON.parse(req.responseText);\n\n                        kc.authServerUrl = config['auth-server-url'];\n                        kc.realm = config['realm'];\n                        kc.clientId = config['resource'];\n                        setupOidcEndoints(null);\n                        promise.setSuccess();\n                    } else {\n                        promise.setError();\n                    }\n                }\n            };\n\n            req.send();\n        } else {\n            kc.clientId = config.clientId;\n\n            var oidcProvider = config['oidcProvider'];\n            if (!oidcProvider) {\n                kc.authServerUrl = config.url;\n                kc.realm = config.realm;\n                setupOidcEndoints(null);\n                promise.setSuccess();\n            } else {\n                if (typeof oidcProvider === 'string') {\n                    var oidcProviderConfigUrl;\n                    if (oidcProvider.charAt(oidcProvider.length - 1) == '/') {\n                        oidcProviderConfigUrl = oidcProvider + '.well-known/openid-configuration';\n                    } else {\n                        oidcProviderConfigUrl = oidcProvider + '/.well-known/openid-configuration';\n                    }\n                    var req = new XMLHttpRequest();\n                    req.open('GET', oidcProviderConfigUrl, true);\n                    req.setRequestHeader('Accept', 'application/json');\n\n                    req.onreadystatechange = function () {\n                        if (req.readyState == 4) {\n                            if (req.status == 200 || fileLoaded(req)) {\n                                var oidcProviderConfig = JSON.parse(req.responseText);\n                                setupOidcEndoints(oidcProviderConfig);\n                                promise.setSuccess();\n                            } else {\n                                promise.setError();\n                            }\n                        }\n                    };\n\n                    req.send();\n                } else {\n                    setupOidcEndoints(oidcProvider);\n                    promise.setSuccess();\n                }\n            }\n        }\n\n        return promise.promise;\n    }\n\n    function fileLoaded(xhr) {\n        return xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith('file:');\n    }\n\n    function setToken(token, refreshToken, idToken, timeLocal) {\n        if (kc.tokenTimeoutHandle) {\n            clearTimeout(kc.tokenTimeoutHandle);\n            kc.tokenTimeoutHandle = null;\n        }\n\n        if (refreshToken) {\n            kc.refreshToken = refreshToken;\n            kc.refreshTokenParsed = decodeToken(refreshToken);\n        } else {\n            delete kc.refreshToken;\n            delete kc.refreshTokenParsed;\n        }\n\n        if (idToken) {\n            kc.idToken = idToken;\n            kc.idTokenParsed = decodeToken(idToken);\n        } else {\n            delete kc.idToken;\n            delete kc.idTokenParsed;\n        }\n\n        if (token) {\n            kc.token = token;\n            kc.tokenParsed = decodeToken(token);\n            kc.sessionId = kc.tokenParsed.sid;\n            kc.authenticated = true;\n            kc.subject = kc.tokenParsed.sub;\n            kc.realmAccess = kc.tokenParsed.realm_access;\n            kc.resourceAccess = kc.tokenParsed.resource_access;\n\n            if (timeLocal) {\n                kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat;\n            }\n\n            if (kc.timeSkew != null) {\n                logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + kc.timeSkew + ' seconds');\n\n                if (kc.onTokenExpired) {\n                    var expiresIn = (kc.tokenParsed['exp'] - (new Date().getTime() / 1000) + kc.timeSkew) * 1000;\n                    logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n                    if (expiresIn <= 0) {\n                        kc.onTokenExpired();\n                    } else {\n                        kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, expiresIn);\n                    }\n                }\n            }\n        } else {\n            delete kc.token;\n            delete kc.tokenParsed;\n            delete kc.subject;\n            delete kc.realmAccess;\n            delete kc.resourceAccess;\n\n            kc.authenticated = false;\n        }\n    }\n\n    function createUUID() {\n        if (typeof crypto === \"undefined\" || typeof crypto.randomUUID === \"undefined\") {\n            throw new Error(\"Web Crypto API is not available.\");\n        }\n\n        return crypto.randomUUID();\n    }\n\n    function parseCallback(url) {\n        var oauth = parseCallbackUrl(url);\n        if (!oauth) {\n            return;\n        }\n\n        var oauthState = callbackStorage.get(oauth.state);\n\n        if (oauthState) {\n            oauth.valid = true;\n            oauth.redirectUri = oauthState.redirectUri;\n            oauth.storedNonce = oauthState.nonce;\n            oauth.prompt = oauthState.prompt;\n            oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n            oauth.loginOptions = oauthState.loginOptions;\n        }\n\n        return oauth;\n    }\n\n    function parseCallbackUrl(url) {\n        var supportedParams;\n        switch (kc.flow) {\n            case 'standard':\n                supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n            case 'implicit':\n                supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n            case 'hybrid':\n                supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n                break;\n        }\n\n        supportedParams.push('error');\n        supportedParams.push('error_description');\n        supportedParams.push('error_uri');\n\n        var queryIndex = url.indexOf('?');\n        var fragmentIndex = url.indexOf('#');\n\n        var newUrl;\n        var parsed;\n\n        if (kc.responseMode === 'query' && queryIndex !== -1) {\n            newUrl = url.substring(0, queryIndex);\n            parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);\n            if (parsed.paramsString !== '') {\n                newUrl += '?' + parsed.paramsString;\n            }\n            if (fragmentIndex !== -1) {\n                newUrl += url.substring(fragmentIndex);\n            }\n        } else if (kc.responseMode === 'fragment' && fragmentIndex !== -1) {\n            newUrl = url.substring(0, fragmentIndex);\n            parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);\n            if (parsed.paramsString !== '') {\n                newUrl += '#' + parsed.paramsString;\n            }\n        }\n\n        if (parsed && parsed.oauthParams) {\n            if (kc.flow === 'standard' || kc.flow === 'hybrid') {\n                if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            } else if (kc.flow === 'implicit') {\n                if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n                    parsed.oauthParams.newUrl = newUrl;\n                    return parsed.oauthParams;\n                }\n            }\n        }\n    }\n\n    function parseCallbackParams(paramsString, supportedParams) {\n        var p = paramsString.split('&');\n        var result = {\n            paramsString: '',\n            oauthParams: {}\n        }\n        for (var i = 0; i < p.length; i++) {\n            var split = p[i].indexOf(\"=\");\n            var key = p[i].slice(0, split);\n            if (supportedParams.indexOf(key) !== -1) {\n                result.oauthParams[key] = p[i].slice(split + 1);\n            } else {\n                if (result.paramsString !== '') {\n                    result.paramsString += '&';\n                }\n                result.paramsString += p[i];\n            }\n        }\n        return result;\n    }\n\n    function createPromise() {\n        // Need to create a native Promise which also preserves the\n        // interface of the custom promise type previously used by the API\n        var p = {\n            setSuccess: function(result) {\n                p.resolve(result);\n            },\n\n            setError: function(result) {\n                p.reject(result);\n            }\n        };\n        p.promise = new Promise(function(resolve, reject) {\n            p.resolve = resolve;\n            p.reject = reject;\n        });\n\n        return p;\n    }\n\n    // Function to extend existing native Promise with timeout\n    function applyTimeoutToPromise(promise, timeout, errorMessage) {\n        var timeoutHandle = null;\n        var timeoutPromise = new Promise(function (resolve, reject) {\n            timeoutHandle = setTimeout(function () {\n                reject({ \"error\": errorMessage || \"Promise is not settled within timeout of \" + timeout + \"ms\" });\n            }, timeout);\n        });\n\n        return Promise.race([promise, timeoutPromise]).finally(function () {\n            clearTimeout(timeoutHandle);\n        });\n    }\n\n    function setupCheckLoginIframe() {\n        var promise = createPromise();\n\n        if (!loginIframe.enable) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n\n        if (loginIframe.iframe) {\n            promise.setSuccess();\n            return promise.promise;\n        }\n\n        var iframe = document.createElement('iframe');\n        loginIframe.iframe = iframe;\n\n        iframe.onload = function() {\n            var authUrl = kc.endpoints.authorize();\n            if (authUrl.charAt(0) === '/') {\n                loginIframe.iframeOrigin = getOrigin();\n            } else {\n                loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf('/', 8));\n            }\n            promise.setSuccess();\n        }\n\n        var src = kc.endpoints.checkSessionIframe();\n        iframe.setAttribute('src', src );\n        iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n        iframe.setAttribute('title', 'keycloak-session-iframe' );\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n\n        var messageCallback = function(event) {\n            if ((event.origin !== loginIframe.iframeOrigin) || (loginIframe.iframe.contentWindow !== event.source)) {\n                return;\n            }\n\n            if (!(event.data == 'unchanged' || event.data == 'changed' || event.data == 'error')) {\n                return;\n            }\n\n\n            if (event.data != 'unchanged') {\n                kc.clearToken();\n            }\n\n            var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);\n\n            for (var i = callbacks.length - 1; i >= 0; --i) {\n                var promise = callbacks[i];\n                if (event.data == 'error') {\n                    promise.setError();\n                } else {\n                    promise.setSuccess(event.data == 'unchanged');\n                }\n            }\n        };\n\n        window.addEventListener('message', messageCallback, false);\n\n        return promise.promise;\n    }\n\n    function scheduleCheckIframe() {\n        if (loginIframe.enable) {\n            if (kc.token) {\n                setTimeout(function() {\n                    checkLoginIframe().then(function(unchanged) {\n                        if (unchanged) {\n                            scheduleCheckIframe();\n                        }\n                    });\n                }, loginIframe.interval * 1000);\n            }\n        }\n    }\n\n    function checkLoginIframe() {\n        var promise = createPromise();\n\n        if (loginIframe.iframe && loginIframe.iframeOrigin ) {\n            var msg = kc.clientId + ' ' + (kc.sessionId ? kc.sessionId : '');\n            loginIframe.callbackList.push(promise);\n            var origin = loginIframe.iframeOrigin;\n            if (loginIframe.callbackList.length == 1) {\n                loginIframe.iframe.contentWindow.postMessage(msg, origin);\n            }\n        } else {\n            promise.setSuccess();\n        }\n\n        return promise.promise;\n    }\n\n    function check3pCookiesSupported() {\n        var promise = createPromise();\n\n        if ((loginIframe.enable || kc.silentCheckSsoRedirectUri) && typeof kc.endpoints.thirdPartyCookiesIframe === 'function') {\n            var iframe = document.createElement('iframe');\n            iframe.setAttribute('src', kc.endpoints.thirdPartyCookiesIframe());\n            iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n            iframe.setAttribute('title', 'keycloak-3p-check-iframe' );\n            iframe.style.display = 'none';\n            document.body.appendChild(iframe);\n\n            var messageCallback = function(event) {\n                if (iframe.contentWindow !== event.source) {\n                    return;\n                }\n\n                if (event.data !== \"supported\" && event.data !== \"unsupported\") {\n                    return;\n                } else if (event.data === \"unsupported\") {\n                    logWarn(\n                        \"[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n\" +\n                        \" - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n\" +\n                        \" - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n\" +\n                        \"For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers\"\n                    );\n\n                    loginIframe.enable = false;\n                    if (kc.silentCheckSsoFallback) {\n                        kc.silentCheckSsoRedirectUri = false;\n                    }\n                }\n\n                document.body.removeChild(iframe);\n                window.removeEventListener(\"message\", messageCallback);\n                promise.setSuccess();\n            };\n\n            window.addEventListener('message', messageCallback, false);\n        } else {\n            promise.setSuccess();\n        }\n\n        return applyTimeoutToPromise(promise.promise, kc.messageReceiveTimeout, \"Timeout when waiting for 3rd party check iframe message.\");\n    }\n\n    function loadAdapter(type) {\n        if (!type || type == 'default') {\n            return {\n                login: async function(options) {\n                    window.location.assign(await kc.createLoginUrl(options));\n                    return createPromise().promise;\n                },\n\n                logout: async function(options) {\n\n                    const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n                    if (logoutMethod === \"GET\") {\n                        window.location.replace(kc.createLogoutUrl(options));\n                        return;\n                    }\n\n                    // Create form to send POST request.\n                    const form = document.createElement(\"form\");\n\n                    form.setAttribute(\"method\", \"POST\");\n                    form.setAttribute(\"action\", kc.createLogoutUrl(options));\n                    form.style.display = \"none\";\n\n                    // Add data to form as hidden input fields.\n                    const data = {\n                        id_token_hint: kc.idToken,\n                        client_id: kc.clientId,\n                        post_logout_redirect_uri: adapter.redirectUri(options, false)\n                    };\n\n                    for (const [name, value] of Object.entries(data)) {\n                        const input = document.createElement(\"input\");\n\n                        input.setAttribute(\"type\", \"hidden\");\n                        input.setAttribute(\"name\", name);\n                        input.setAttribute(\"value\", value);\n\n                        form.appendChild(input);\n                    }\n\n                    // Append form to page and submit it to perform logout and redirect.\n                    document.body.appendChild(form);\n                    form.submit();\n                },\n\n                register: async function(options) {\n                    window.location.assign(await kc.createRegisterUrl(options));\n                    return createPromise().promise;\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        window.location.href = accountUrl;\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                    return createPromise().promise;\n                },\n\n                redirectUri: function(options, encodeHash) {\n                    if (arguments.length == 1) {\n                        encodeHash = true;\n                    }\n\n                    if (options && options.redirectUri) {\n                        return options.redirectUri;\n                    } else if (kc.redirectUri) {\n                        return kc.redirectUri;\n                    } else {\n                        return location.href;\n                    }\n                }\n            };\n        }\n\n        if (type == 'cordova') {\n            loginIframe.enable = false;\n            var cordovaOpenWindowWrapper = function(loginUrl, target, options) {\n                if (window.cordova && window.cordova.InAppBrowser) {\n                    // Use inappbrowser for IOS and Android if available\n                    return window.cordova.InAppBrowser.open(loginUrl, target, options);\n                } else {\n                    return window.open(loginUrl, target, options);\n                }\n            };\n\n            var shallowCloneCordovaOptions = function (userOptions) {\n                if (userOptions && userOptions.cordovaOptions) {\n                    return Object.keys(userOptions.cordovaOptions).reduce(function (options, optionName) {\n                        options[optionName] = userOptions.cordovaOptions[optionName];\n                        return options;\n                    }, {});\n                } else {\n                    return {};\n                }\n            };\n\n            var formatCordovaOptions = function (cordovaOptions) {\n                return Object.keys(cordovaOptions).reduce(function (options, optionName) {\n                    options.push(optionName+\"=\"+cordovaOptions[optionName]);\n                    return options;\n                }, []).join(\",\");\n            };\n\n            var createCordovaOptions = function (userOptions) {\n                var cordovaOptions = shallowCloneCordovaOptions(userOptions);\n                cordovaOptions.location = 'no';\n                if (userOptions && userOptions.prompt == 'none') {\n                    cordovaOptions.hidden = 'yes';\n                }\n                return formatCordovaOptions(cordovaOptions);\n            };\n\n            var getCordovaRedirectUri = function() {\n                return kc.redirectUri || 'http://localhost';\n            }\n\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n\n                    var cordovaOptions = createCordovaOptions(options);\n                    var loginUrl = await kc.createLoginUrl(options);\n                    var ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n                    var completed = false;\n\n                    var closed = false;\n                    var closeBrowser = function() {\n                        closed = true;\n                        ref.close();\n                    };\n\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            var callback = parseCallback(event.url);\n                            processCallback(callback, promise);\n                            closeBrowser();\n                            completed = true;\n                        }\n                    });\n\n                    ref.addEventListener('loaderror', function(event) {\n                        if (!completed) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                                var callback = parseCallback(event.url);\n                                processCallback(callback, promise);\n                                closeBrowser();\n                                completed = true;\n                            } else {\n                                promise.setError();\n                                closeBrowser();\n                            }\n                        }\n                    });\n\n                    ref.addEventListener('exit', function(event) {\n                        if (!closed) {\n                            promise.setError({\n                                reason: \"closed_by_user\"\n                            });\n                        }\n                    });\n\n                    return promise.promise;\n                },\n\n                logout: function(options) {\n                    var promise = createPromise();\n\n                    var logoutUrl = kc.createLogoutUrl(options);\n                    var ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n\n                    var error;\n\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                        }\n                    });\n\n                    ref.addEventListener('loaderror', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                        } else {\n                            error = true;\n                            ref.close();\n                        }\n                    });\n\n                    ref.addEventListener('exit', function(event) {\n                        if (error) {\n                            promise.setError();\n                        } else {\n                            kc.clearToken();\n                            promise.setSuccess();\n                        }\n                    });\n\n                    return promise.promise;\n                },\n\n                register : async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl();\n                    var cordovaOptions = createCordovaOptions(options);\n                    var ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n                    ref.addEventListener('loadstart', function(event) {\n                        if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                            ref.close();\n                            var oauth = parseCallback(event.url);\n                            processCallback(oauth, promise);\n                        }\n                    });\n                    return promise.promise;\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        var ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n                        ref.addEventListener('loadstart', function(event) {\n                            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                                ref.close();\n                            }\n                        });\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                },\n\n                redirectUri: function(options) {\n                    return getCordovaRedirectUri();\n                }\n            }\n        }\n\n        if (type == 'cordova-native') {\n            loginIframe.enable = false;\n\n            return {\n                login: async function(options) {\n                    var promise = createPromise();\n                    var loginUrl = await kc.createLoginUrl(options);\n\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n\n                    window.cordova.plugins.browsertab.openUrl(loginUrl);\n                    return promise.promise;\n                },\n\n                logout: function(options) {\n                    var promise = createPromise();\n                    var logoutUrl = kc.createLogoutUrl(options);\n\n                    universalLinks.subscribe('keycloak', function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        kc.clearToken();\n                        promise.setSuccess();\n                    });\n\n                    window.cordova.plugins.browsertab.openUrl(logoutUrl);\n                    return promise.promise;\n                },\n\n                register : async function(options) {\n                    var promise = createPromise();\n                    var registerUrl = await kc.createRegisterUrl(options);\n                    universalLinks.subscribe('keycloak' , function(event) {\n                        universalLinks.unsubscribe('keycloak');\n                        window.cordova.plugins.browsertab.close();\n                        var oauth = parseCallback(event.url);\n                        processCallback(oauth, promise);\n                    });\n                    window.cordova.plugins.browsertab.openUrl(registerUrl);\n                    return promise.promise;\n\n                },\n\n                accountManagement : function() {\n                    var accountUrl = kc.createAccountUrl();\n                    if (typeof accountUrl !== 'undefined') {\n                        window.cordova.plugins.browsertab.openUrl(accountUrl);\n                    } else {\n                        throw \"Not supported by the OIDC server\";\n                    }\n                },\n\n                redirectUri: function(options) {\n                    if (options && options.redirectUri) {\n                        return options.redirectUri;\n                    } else if (kc.redirectUri) {\n                        return kc.redirectUri;\n                    } else {\n                        return \"http://localhost\";\n                    }\n                }\n            }\n        }\n\n        throw 'invalid adapter type: ' + type;\n    }\n\n    const STORAGE_KEY_PREFIX = 'kc-callback-';\n\n    var LocalStorage = function() {\n        if (!(this instanceof LocalStorage)) {\n            return new LocalStorage();\n        }\n\n        localStorage.setItem('kc-test', 'test');\n        localStorage.removeItem('kc-test');\n\n        var cs = this;\n\n        /**\n         * Clears all values from local storage that are no longer valid.\n         */\n        function clearInvalidValues() {\n            const currentTime = Date.now();\n\n            for (const [key, value] of getStoredEntries()) {\n                // Attempt to parse the expiry time from the value.\n                const expiry = parseExpiry(value);\n\n                // Discard the value if it is malformed or expired.\n                if (expiry === null || expiry < currentTime) {\n                    localStorage.removeItem(key);\n                }\n            }\n        }\n\n        /**\n         * Clears all known values from local storage.\n         */\n        function clearAllValues() {\n            for (const [key] of getStoredEntries()) {\n                localStorage.removeItem(key);\n            }\n        }\n\n        /**\n         * Gets all entries stored in local storage that are known to be managed by this class.\n         * @returns {Array<[string, unknown]>} An array of key-value pairs.\n         */\n        function getStoredEntries() {\n            return Object.entries(localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX));\n        }\n\n        /**\n         * Parses the expiry time from a value stored in local storage.\n         * @param {unknown} value\n         * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n         */\n        function parseExpiry(value) {\n            let parsedValue;\n\n            // Attempt to parse the value as JSON.\n            try {\n                parsedValue = JSON.parse(value);\n            } catch (error) {\n                return null;\n            }\n\n            // Attempt to extract the 'expires' property.\n            if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n                return parsedValue.expires;\n            }\n\n            return null;\n        }\n\n        cs.get = function(state) {\n            if (!state) {\n                return;\n            }\n\n            var key = STORAGE_KEY_PREFIX + state;\n            var value = localStorage.getItem(key);\n            if (value) {\n                localStorage.removeItem(key);\n                value = JSON.parse(value);\n            }\n\n            clearInvalidValues();\n            return value;\n        };\n\n        cs.add = function(state) {\n            clearInvalidValues();\n\n            const key = STORAGE_KEY_PREFIX + state.state;\n            const value = JSON.stringify({\n                ...state,\n                // Set the expiry time to 1 hour from now.\n                expires: Date.now() + (60 * 60 * 1000)\n            });\n\n            try {\n                localStorage.setItem(key, value);\n            } catch (error) {\n                // If the storage is full, clear all known values and try again.\n                clearAllValues();\n                localStorage.setItem(key, value);\n            }\n        };\n    };\n\n    var CookieStorage = function() {\n        if (!(this instanceof CookieStorage)) {\n            return new CookieStorage();\n        }\n\n        var cs = this;\n\n        cs.get = function(state) {\n            if (!state) {\n                return;\n            }\n\n            var value = getCookie(STORAGE_KEY_PREFIX + state);\n            setCookie(STORAGE_KEY_PREFIX + state, '', cookieExpiration(-100));\n            if (value) {\n                return JSON.parse(value);\n            }\n        };\n\n        cs.add = function(state) {\n            setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), cookieExpiration(60));\n        };\n\n        cs.removeItem = function(key) {\n            setCookie(key, '', cookieExpiration(-100));\n        };\n\n        var cookieExpiration = function (minutes) {\n            var exp = new Date();\n            exp.setTime(exp.getTime() + (minutes*60*1000));\n            return exp;\n        };\n\n        var getCookie = function (key) {\n            var name = key + '=';\n            var ca = document.cookie.split(';');\n            for (var i = 0; i < ca.length; i++) {\n                var c = ca[i];\n                while (c.charAt(0) == ' ') {\n                    c = c.substring(1);\n                }\n                if (c.indexOf(name) == 0) {\n                    return c.substring(name.length, c.length);\n                }\n            }\n            return '';\n        };\n\n        var setCookie = function (key, value, expirationDate) {\n            var cookie = key + '=' + value + '; '\n                + 'expires=' + expirationDate.toUTCString() + '; ';\n            document.cookie = cookie;\n        }\n    };\n\n    function createCallbackStorage() {\n        try {\n            return new LocalStorage();\n        } catch (err) {\n        }\n\n        return new CookieStorage();\n    }\n\n    function createLogger(fn) {\n        return function() {\n            if (kc.enableLogging) {\n                fn.apply(console, Array.prototype.slice.call(arguments));\n            }\n        };\n    }\n}\n\nexport default Keycloak;\n\n/**\n * @param {ArrayBuffer} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64(bytes) {\n    const binString = String.fromCodePoint(...bytes);\n    return btoa(binString);\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest(message) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(message);\n\n    if (typeof crypto === \"undefined\" || typeof crypto.subtle === \"undefined\") {\n        throw new Error(\"Web Crypto API is not available.\");\n    }\n\n    return await crypto.subtle.digest(\"SHA-256\", data);\n}\n\n/**\n * @param {string} token\n */\nfunction decodeToken(token) {\n    const [header, payload] = token.split(\".\");\n\n    if (typeof payload !== \"string\") {\n        throw new Error(\"Unable to decode token, payload not found.\");\n    }\n\n    let decoded;\n\n    try {\n        decoded = base64UrlDecode(payload);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid Base64URL value.\", { cause: error });\n    }\n\n    try {\n        return JSON.parse(decoded);\n    } catch (error) {\n        throw new Error(\"Unable to decode token, payload is not a valid JSON value.\", { cause: error });\n    }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode(input) {\n    let output = input\n        .replaceAll(\"-\", \"+\")\n        .replaceAll(\"_\", \"/\");\n\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"Input is not of the correct length.\");\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (error) {\n        return atob(output);\n    }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode(input) {\n    return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n\n        return \"%\" + code;\n    }));\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject(input) {\n    return typeof input === 'object' && input !== null;\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","self","window","global","register","module","exports","Object","defineProperty","get","$0070b44f7a8953d5$export$2e2bcd8739ae039","set","s","enumerable","configurable","$0070b44f7a8953d5$var$Keycloak","config","Error","$0070b44f7a8953d5$var$isObject","property","adapter","callbackStorage","kc","refreshQueue","loginIframe","enable","callbackList","interval","didInitialize","useNonce","logInfo","createLogger","console","info","logWarn","warn","generatePkceChallenge","pkceMethod","codeVerifier","TypeError","$0070b44f7a8953d5$var$bytesToBase64","btoa","String","fromCodePoint","Uint8Array","$0070b44f7a8953d5$var$sha256Digest","replace","getRealmUrl","authServerUrl","charAt","length","encodeURIComponent","realm","processCallback","oauth","promise","code","error","prompt","timeLocal","Date","getTime","onActionUpdate","error_description","login","loginOptions","errorData","onAuthError","setError","setSuccess","flow","access_token","id_token","authSuccess","params","url","endpoints","token","req","XMLHttpRequest","open","setRequestHeader","clientId","redirectUri","pkceCodeVerifier","withCredentials","onreadystatechange","readyState","status","tokenResponse","JSON","parse","responseText","scheduleCheckIframe","send","accessToken","refreshToken","idToken","fulfillPromise","setToken","idTokenParsed","nonce","storedNonce","clearToken","onAuthSuccess","fileLoaded","xhr","responseURL","startsWith","tokenTimeoutHandle","clearTimeout","refreshTokenParsed","$0070b44f7a8953d5$var$decodeToken","tokenParsed","sessionId","sid","authenticated","subject","sub","realmAccess","realm_access","resourceAccess","resource_access","timeSkew","Math","floor","iat","onTokenExpired","expiresIn","round","setTimeout","createUUID","crypto","randomUUID","parseCallback","parseCallbackUrl","supportedParams","push","newUrl","parsed","queryIndex","indexOf","fragmentIndex","responseMode","substring","parseCallbackParams","paramsString","oauthParams","state","oauthState","valid","p","split","result","i","key","slice","createPromise","resolve","reject","Promise","setupCheckLoginIframe","iframe","document","createElement","onload","authUrl","authorize","iframeOrigin","location","origin","protocol","hostname","port","src","checkSessionIframe","setAttribute","style","display","body","appendChild","addEventListener","event","contentWindow","source","data","callbacks","splice","checkLoginIframe","then","unchanged","msg","postMessage","loadAdapter","type","options","assign","createLoginUrl","logout","logoutMethod","createLogoutUrl","form","name","value","entries","id_token_hint","client_id","post_logout_redirect_uri","input","submit","createRegisterUrl","accountManagement","accountUrl","createAccountUrl","href","encodeHash","cordovaOpenWindowWrapper","loginUrl","target","cordova","InAppBrowser","createCordovaOptions","userOptions","cordovaOptions","keys","reduce","optionName","hidden","join","getCordovaRedirectUri","ref","completed","closed","closeBrowser","close","reason","universalLinks","subscribe","unsubscribe","plugins","browsertab","openUrl","logoutUrl","registerUrl","isSecureContext","init","initOptions","createCallbackStorage","LocalStorage","err","CookieStorage","adapters","Cordova","checkLoginIframeInterval","onLoad","loginRequired","responseType","silentCheckSsoRedirectUri","silentCheckSsoFallback","enableLogging","scope","acrValues","messageReceiveTimeout","initPromise","onReady","catch","configPromise","loadConfig","setupOidcEndoints","oidcConfiguration","authorization_endpoint","token_endpoint","end_session_endpoint","check_session_iframe","userinfo","userinfo_endpoint","thirdPartyCookiesIframe","configUrl","oidcProvider","oidcProviderConfigUrl","doLogin","locale","checkSsoSilently","ifrm","messageCallback","removeChild","removeEventListener","processInit","callback","history","replaceState","updateToken","check3pCookiesSupported","timeout","errorMessage","timeoutHandle","race","finally","baseUrl","callbackState","action","maxAge","loginHint","idpHint","acr","stringify","generateRandomString","len","alphabet","randomData","generateRandomData","getRandomValues","chars","Array","charCodeAt","fromCharCode","apply","pkceChallenge","cause","add","undefined","hasRealmRole","role","access","roles","hasResourceRole","resource","loadUserProfile","profile","loadUserInfo","userInfo","isTokenExpired","minValidity","ceil","isNaN","exec","onAuthRefreshSuccess","pop","onAuthRefreshError","iframePromise","onAuthLogout","STORAGE_KEY_PREFIX","clearInvalidValues","currentTime","now","getStoredEntries","expiry","parseExpiry","parsedValue","expires","localStorage","removeItem","filter","setItem","cs","getItem","getCookie","setCookie","cookieExpiration","minutes","exp","setTime","ca","cookie","c","expirationDate","toUTCString","fn","prototype","call","arguments","message","encoder","TextEncoder","encode","subtle","digest","decoded","header","payload","$0070b44f7a8953d5$var$base64UrlDecode","output","replaceAll","decodeURIComponent","atob","m","toString","toUpperCase"],"version":3,"file":"keycloak.7621e41e.js.map"}